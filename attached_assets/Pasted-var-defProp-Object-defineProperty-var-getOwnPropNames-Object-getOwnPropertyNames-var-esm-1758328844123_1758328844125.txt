var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/services/gemini.ts
var gemini_exports = {};
__export(gemini_exports, {
  enhancePromptWithGemini: () => enhancePromptWithGemini,
  enhanceVideoPromptFromGeneratedImage: () => enhanceVideoPromptFromGeneratedImage,
  enhanceVideoPromptWithGemini: () => enhanceVideoPromptWithGemini,
  generateImageWithGemini: () => generateImageWithGemini
});
import { GoogleGenerativeAI } from "@google/generative-ai";
async function getImageDataFromStorage(filePath) {
  try {
    console.log("Getting image from storage:", filePath);
    let filename = null;
    if (filePath.startsWith("http")) {
      if (filePath.includes("cloudinary.com") || filePath.includes("res.cloudinary.com")) {
        console.log("Fetching Cloudinary image:", filePath);
        try {
          const response = await fetch(filePath);
          if (!response.ok) {
            throw new Error(`Failed to fetch Cloudinary image: ${response.status} ${response.statusText}`);
          }
          const buffer = await response.arrayBuffer();
          const base64 = Buffer.from(buffer).toString("base64");
          const mimeType = response.headers.get("content-type") || "image/jpeg";
          console.log("Cloudinary image loaded successfully:", {
            url: filePath,
            bufferLength: buffer.byteLength,
            base64Length: base64.length,
            mimeType
          });
          return { base64, mimeType };
        } catch (error) {
          console.error("Error fetching Cloudinary image:", error);
          throw new Error(`Failed to load Cloudinary image: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      const urlPath = new URL(filePath).pathname;
      const match = urlPath.match(/\/api\/files\/uploads\/(.+)/);
      if (match) {
        filename = match[1];
      }
    } else if (filePath.includes("/api/files/uploads/")) {
      const match = filePath.match(/\/api\/files\/uploads\/(.+)/);
      if (match) {
        filename = match[1];
      }
    } else if (filePath.startsWith("product-")) {
      filename = filePath;
    }
    if (filename) {
      const localPath = `/tmp/uploads/${filename}`;
      console.log("Reading local file:", localPath);
      const fs3 = await import("fs/promises");
      const path4 = await import("path");
      try {
        await fs3.access(localPath);
        const buffer = await fs3.readFile(localPath);
        const ext = path4.extname(filename).toLowerCase();
        const mimeTypes = {
          ".jpg": "image/jpeg",
          ".jpeg": "image/jpeg",
          ".png": "image/png",
          ".gif": "image/gif",
          ".webp": "image/webp"
        };
        const mimeType = mimeTypes[ext] || "image/jpeg";
        const base64 = buffer.toString("base64");
        console.log("Image loaded from local file:", {
          filePath: localPath,
          bufferLength: buffer.length,
          base64Length: base64.length,
          mimeType,
          fileName: filename
        });
        return { base64, mimeType };
      } catch (fileError) {
        console.error("Error reading local file:", fileError);
        throw new Error(`File not found: ${localPath}`);
      }
    }
    throw new Error(`Could not load image from: ${filePath}. File not found in local storage or Cloudinary.`);
  } catch (error) {
    console.error("Error getting image from storage:", error);
    throw error;
  }
}
async function enhancePromptWithGemini(productImagePath, sceneImagePath, userDescription) {
  try {
    console.log("Gemini API request details:", {
      productImagePath,
      sceneImagePath,
      userDescription: userDescription.substring(0, 50),
      apiKeyExists: !!process.env.GEMINI_API_KEY,
      apiKeyLength: process.env.GEMINI_API_KEY?.length || 0
    });
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    console.log("Loading images from Object Storage...");
    const [productImageData, sceneImageData] = await Promise.all([
      getImageDataFromStorage(productImagePath),
      getImageDataFromStorage(sceneImagePath)
    ]);
    const prompt = `
\u0627\u0646\u062A \u062E\u0628\u064A\u0631 CGI \u0645\u062A\u0642\u062F\u0645 \u0648\u0647\u0627\u062A\u0639\u0645\u0644 \u062A\u0639\u0644\u064A\u0645\u0627\u062A \u062F\u0642\u064A\u0642\u0629 \u0644\u062A\u0648\u0644\u064A\u062F \u0627\u0644\u0635\u0648\u0631 \u0628\u0627\u0644\u0630\u0643\u0627\u0621 \u0627\u0644\u0627\u0635\u0637\u0646\u0627\u0639\u064A.

\u0642\u0645 \u0628\u062A\u062D\u0644\u064A\u0644 \u0627\u0644\u0635\u0648\u0631\u062A\u064A\u0646 \u062F\u0648\u0644 \u0628\u062F\u0642\u0629:
1. \u0635\u0648\u0631\u0629 \u0627\u0644\u0645\u0646\u062A\u062C: \u0639\u0631\u0641 \u0627\u0633\u0645 \u0627\u0644\u0645\u0646\u062A\u062C \u0648\u0627\u0644\u0628\u0631\u0627\u0646\u062F \u0648\u0627\u0644\u0634\u0643\u0644 \u0648\u0627\u0644\u0627\u0644\u0648\u0627\u0646
2. \u0635\u0648\u0631\u0629 \u0627\u0644\u0645\u0634\u0647\u062F: \u0634\u0648\u0641 \u0627\u064A\u0647 \u0627\u0644\u0645\u0648\u062C\u0648\u062F \u0648\u0627\u0644\u0627\u0636\u0627\u0621\u0629 \u0648\u0627\u0644\u0628\u064A\u0626\u0629

\u0627\u0644\u0645\u0637\u0644\u0648\u0628 \u0645\u0646\u0643 - \u062A\u062D\u0644\u064A\u0644 \u0630\u0643\u064A \u0644\u0644\u062A\u0639\u0627\u0631\u0636\u0627\u062A:

\u{1F50D} \u062E\u0637\u0648\u0629 1: \u062A\u062D\u0644\u064A\u0644 \u0627\u0644\u062A\u0639\u0627\u0631\u0636\u0627\u062A \u0627\u0644\u0630\u0643\u064A
- \u0627\u062D\u0644\u0644 \u0637\u0644\u0628 \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645: "${userDescription}"
- \u0634\u0648\u0641 \u0627\u064A\u0647 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0645\u0648\u062C\u0648\u062F\u0629 \u0641\u064A \u0627\u0644\u0645\u0634\u0647\u062F \u0627\u0644\u0644\u064A \u0647\u062A\u062A\u0639\u0627\u0631\u0636 \u0645\u0639 \u0627\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u062C\u062F\u064A\u062F
- \u0627\u0645\u062B\u0644\u0629 \u0644\u0644\u062A\u0639\u0627\u0631\u0636\u0627\u062A:
  * \u0627\u0636\u0627\u0641\u0629 \u0646\u062C\u0641\u0629 \u2192 \u0634\u064A\u0644 \u0627\u0644\u0646\u0628\u0627\u062A\u0627\u062A \u0627\u0644\u0645\u0639\u0644\u0642\u0629 \u0623\u0648 \u0627\u0644\u0627\u0636\u0627\u0621\u0629 \u0627\u0644\u0645\u0648\u062C\u0648\u062F\u0629
  * \u0627\u0636\u0627\u0641\u0629 \u0643\u0646\u0628\u0629 \u2192 \u0634\u064A\u0644 \u0627\u0644\u0643\u0631\u0627\u0633\u064A \u0623\u0648 \u0627\u0644\u0627\u062B\u0627\u062B \u0627\u0644\u0644\u064A \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0645\u0643\u0627\u0646
  * \u0627\u0636\u0627\u0641\u0629 \u0644\u0648\u062D\u0629 \u2192 \u0634\u064A\u0644 \u0627\u0644\u0644\u0648\u062D\u0627\u062A \u0627\u0644\u0645\u0648\u062C\u0648\u062F\u0629 \u0639\u0644\u0649 \u0646\u0641\u0633 \u0627\u0644\u062D\u064A\u0637\u0629
  * \u0627\u0636\u0627\u0641\u0629 \u0637\u0627\u0648\u0644\u0629 \u2192 \u0634\u064A\u0644 \u0627\u0644\u0637\u0627\u0648\u0644\u0629 \u0627\u0644\u0645\u0648\u062C\u0648\u062F\u0629 \u0623\u0648 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0644\u064A \u0639\u0644\u0649 \u0627\u0644\u0627\u0631\u0636

\u{1F5D1}\uFE0F \u062E\u0637\u0648\u0629 2: \u0627\u0644\u0634\u064A\u0644 \u0627\u0644\u0630\u0643\u064A \u0644\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0645\u062A\u0639\u0627\u0631\u0636\u0629
1. \u0627\u0645\u0633\u062D \u0648\u0634\u064A\u0644 \u0646\u0647\u0627\u0626\u064A\u0627\u064B \u0643\u0644 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0645\u062A\u0639\u0627\u0631\u0636\u0629 - \u062E\u0644\u064A\u0647\u0627 \u062A\u062E\u062A\u0641\u064A \u062A\u0645\u0627\u0645\u0627\u064B
2. \u0627\u0645\u0633\u062D \u0648\u0634\u064A\u0644 \u0646\u0647\u0627\u0626\u064A\u0627\u064B \u0627\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u0645\u0648\u062C\u0648\u062F (\u0644\u0648 \u0641\u064A) - \u062E\u0644\u064A\u0647 \u064A\u062E\u062A\u0641\u064A \u062A\u0645\u0627\u0645\u0627\u064B  
3. \u062E\u0644\u064A \u0627\u0644\u0645\u0643\u0627\u0646 \u064A\u0641\u0636\u0649 \u0648\u0646\u0638\u064A\u0641 \u0642\u0628\u0644 \u0627\u0636\u0627\u0641\u0629 \u0627\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u062C\u062F\u064A\u062F

\u{1F3AF} \u062E\u0637\u0648\u0629 3: \u0627\u0644\u0627\u0636\u0627\u0641\u0629 \u0627\u0644\u0630\u0643\u064A\u0629
1. \u062D\u0637 \u0627\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u062C\u062F\u064A\u062F \u0641\u064A \u0627\u0644\u0645\u0643\u0627\u0646 \u0627\u0644\u0645\u0646\u0627\u0633\u0628 \u0644\u064A\u0647
2. \u062E\u0644\u064A \u0627\u0644\u0627\u0636\u0627\u0621\u0629 \u0648\u0627\u0644\u0638\u0644\u0627\u0644 \u0645\u062A\u0637\u0627\u0628\u0642\u0629 \u062A\u0645\u0627\u0645\u0627\u064B
3. \u0627\u062D\u062A\u0641\u0638 \u0628\u0643\u0644 \u0627\u0644\u0639\u0645\u0627\u0631\u0629 (\u0627\u0644\u0633\u0642\u0641 \u0648\u0627\u0644\u062D\u064A\u0637\u0627\u0646 \u0648\u0627\u0644\u0627\u0631\u0636\u064A\u0629) \u0632\u064A \u0645\u0627 \u0647\u064A
4. \u0627\u062D\u062A\u0641\u0638 \u0628\u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0644\u064A \u0645\u0634 \u0645\u062A\u0639\u0627\u0631\u0636\u0629 (\u0632\u064A \u0627\u0644\u0646\u0627\u0633\u060C \u0627\u0644\u0646\u0648\u0627\u0641\u0630\u060C \u0627\u0644\u062F\u064A\u0643\u0648\u0631\u0627\u062A \u0627\u0644\u0628\u0639\u064A\u062F\u0629)

\u{1F6A8} \u0642\u0648\u0627\u0639\u062F \u0627\u0644\u0634\u064A\u0644 \u0627\u0644\u0630\u0643\u064A \u0627\u0644\u0645\u0647\u0645\u0629:
- \u0641\u0643\u0631 \u0623\u0648\u0644: \u0627\u064A\u0647 \u0627\u0644\u0644\u064A \u0647\u064A\u062A\u0639\u0627\u0631\u0636 \u0645\u0639 \u0627\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u062C\u062F\u064A\u062F\u061F
- \u0627\u0634\u064A\u0644 \u0643\u0644 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0645\u062A\u0639\u0627\u0631\u0636\u0629 \u0646\u0647\u0627\u0626\u064A\u0627\u064B (\u0645\u0634 \u0628\u0642\u0627\u064A\u0627 \u0627\u0648 \u0627\u062B\u0627\u0631)
- \u0627\u0644\u0645\u0643\u0627\u0646 \u064A\u062A\u0645\u0644\u064A \u0637\u0628\u064A\u0639\u064A \u0648\u0646\u0638\u064A\u0641 \u0642\u0628\u0644 \u0627\u0644\u0627\u0636\u0627\u0641\u0629
- \u0627\u0644\u062A\u0631\u0643\u064A\u0632 \u0639\u0644\u0649 \u0627\u0644\u0627\u0633\u062A\u0628\u062F\u0627\u0644 \u0627\u0644\u0630\u0643\u064A \u0645\u0634 \u0645\u062C\u0631\u062F \u0627\u0636\u0627\u0641\u0629 \u0641\u0648\u0642 \u0627\u0644\u0645\u0648\u062C\u0648\u062F
- \u0627\u0639\u0645\u0644 \u0645\u0633\u0627\u062D\u0629 \u0645\u0646\u0627\u0633\u0628\u0629 \u0644\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u062C\u062F\u064A\u062F

\u0627\u0643\u062A\u0628 \u062A\u0639\u0644\u064A\u0645\u0627\u062A \u0645\u0628\u0627\u0634\u0631\u0629 \u0628\u0627\u0644\u0627\u0646\u062C\u0644\u064A\u0632\u064A \u0644\u0644\u0630\u0643\u0627\u0621 \u0627\u0644\u0627\u0635\u0637\u0646\u0627\u0639\u064A \u062A\u0634\u0645\u0644 \u0627\u0644\u0634\u064A\u0644 \u0627\u0644\u0630\u0643\u064A \u0623\u0648\u0644\u0627\u064B \u062B\u0645 \u0627\u0644\u0627\u0636\u0627\u0641\u0629.

`;
    const result = await model.generateContent([
      prompt,
      {
        inlineData: {
          data: productImageData.base64,
          mimeType: productImageData.mimeType
        }
      },
      {
        inlineData: {
          data: sceneImageData.base64,
          mimeType: sceneImageData.mimeType
        }
      }
    ]);
    const response = await result.response;
    const enhancedPrompt = response.text();
    console.log("Gemini enhanced prompt:", enhancedPrompt);
    return enhancedPrompt;
  } catch (error) {
    console.error("Gemini API error:", error);
    return `Professional CGI integration of product into scene with realistic lighting, shadows, and natural placement. High quality, photorealistic rendering. ${userDescription}`;
  }
}
async function generateImageWithGemini(productImagePath, sceneImagePath, enhancedPrompt) {
  try {
    console.log("Gemini Image Generation request:", {
      productImagePath,
      sceneImagePath,
      promptLength: enhancedPrompt.length,
      promptPreview: enhancedPrompt.substring(0, 100) + "..."
    });
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-image-preview" });
    console.log("Loading images for Gemini Image Generation...");
    const [productImageData, sceneImageData] = await Promise.all([
      getImageDataFromStorage(productImagePath),
      getImageDataFromStorage(sceneImagePath)
    ]);
    const prompt = `
GENERATE A NEW IMAGE by composing these two input images:

INPUT 1 (Product): Extract this exact product/object
INPUT 2 (Scene): Place the product into this environment

COMPOSITION INSTRUCTIONS:
${enhancedPrompt}

CRITICAL IMAGE GENERATION REQUIREMENTS:
- CREATE A NEW PHOTOREALISTIC IMAGE (not text description)
- Extract the product from image 1 and seamlessly place it in scene from image 2
- Preserve scene background 100% exactly (lighting, people, buildings, textures)
- Match lighting, shadows, and perspective perfectly
- Ultra-sharp details, high resolution (1024x1024 minimum)
- Use exact product branding, colors, and shape from first image
- Professional CGI quality with no compositing artifacts
- OUTPUT: Return the generated composite image, not text analysis

GENERATE THE COMPOSITE IMAGE NOW.
`;
    const result = await model.generateContent([
      prompt,
      {
        inlineData: {
          data: productImageData.base64,
          mimeType: productImageData.mimeType
        }
      },
      {
        inlineData: {
          data: sceneImageData.base64,
          mimeType: sceneImageData.mimeType
        }
      }
    ]);
    const response = await result.response;
    const candidates = response.candidates;
    if (!candidates || candidates.length === 0) {
      throw new Error("No image generated by Gemini - no candidates in response");
    }
    const parts = candidates[0].content.parts;
    if (!parts || parts.length === 0) {
      throw new Error("No content parts in Gemini response");
    }
    for (const part of parts) {
      if (part.inlineData && part.inlineData.mimeType?.startsWith("image/")) {
        const imageBase64 = part.inlineData.data;
        const mimeType = part.inlineData.mimeType;
        console.log("Gemini image generated successfully (inlineData):", {
          base64Length: imageBase64.length,
          mimeType,
          responseStructure: "inlineData"
        });
        return { base64: imageBase64, mimeType };
      }
      if (part.fileData && part.fileData.mimeType?.startsWith("image/")) {
        const fileUri = part.fileData.fileUri;
        const mimeType = part.fileData.mimeType;
        console.log("Gemini fileData detected - fetching remote URI:", {
          fileUri,
          mimeType,
          responseStructure: "fileData"
        });
        if (fileUri) {
          try {
            const response2 = await fetch(fileUri);
            if (!response2.ok) {
              throw new Error(`Failed to fetch file from URI: ${response2.status}`);
            }
            const imageBuffer = await response2.arrayBuffer();
            const imageBase64 = Buffer.from(imageBuffer).toString("base64");
            const actualMimeType = response2.headers.get("content-type") || mimeType;
            console.log("Gemini image fetched successfully (fileData):", {
              base64Length: imageBase64.length,
              mimeType: actualMimeType,
              originalUri: fileUri,
              responseStructure: "fileData"
            });
            return { base64: imageBase64, mimeType: actualMimeType };
          } catch (fetchError) {
            console.error("Failed to fetch fileData URI:", fetchError);
          }
        }
      }
    }
    console.error("Gemini response structure analysis:", JSON.stringify({
      candidatesCount: candidates.length,
      partsCount: parts.length,
      partTypes: parts.map((p) => Object.keys(p)),
      fullParts: parts.slice(0, 2),
      // Log first 2 parts for debugging
      detailedPartAnalysis: parts.map((part, index2) => ({
        partIndex: index2,
        keys: Object.keys(part),
        hasInlineData: !!part.inlineData,
        hasFileData: !!part.fileData,
        inlineDataMimeType: part.inlineData?.mimeType,
        fileDataMimeType: part.fileData?.mimeType,
        textContent: part.text?.substring(0, 100)
      }))
    }, null, 2));
    console.warn("Scene preservation may be insufficient - no image generated");
    throw new Error("No image data found in Gemini response - check response structure analysis above");
  } catch (error) {
    console.error("Gemini Image Generation error:", error);
    throw new Error(`Failed to generate image with Gemini: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function enhanceVideoPromptWithGemini(productImagePath, sceneMediaPath, userDescription, options = {}) {
  try {
    console.log("Gemini Video Prompt Enhancement:", {
      productImagePath,
      sceneMediaPath,
      userDescription: userDescription.substring(0, 50),
      duration: options.duration || 5,
      isSceneVideo: options.isSceneVideo || false,
      apiKeyExists: !!process.env.GEMINI_API_KEY
    });
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    console.log("Loading media for video prompt generation...");
    const productImageData = await getImageDataFromStorage(productImagePath);
    const sceneImageData = options.isSceneVideo ? null : await getImageDataFromStorage(sceneMediaPath);
    const durationSeconds = options.duration || 5;
    const isShortVideo = durationSeconds <= 5;
    const prompt = `
\u{1F3AF} TWO-PHASE CGI VIDEO SYSTEM: Separate Static Scene from Motion

ANALYZE the images:
1. PRODUCT: Identify key features and design
2. SCENE: Environment, lighting, layout

USER REQUEST: "${userDescription}"

\u{1F50D} CRITICAL TASK: INTELLIGENT CONFLICT ANALYSIS + TWO PHASES:

PHASE 0 - SMART CONFLICT ANALYSIS:
- Analyze user request: "${userDescription}"
- Identify existing scene elements that CONFLICT with new product
- Examples of conflicts:
  * Adding chandelier \u2192 Remove hanging plants, existing lighting fixtures
  * Adding sofa \u2192 Remove chairs or furniture in same area  
  * Adding wall art \u2192 Remove existing paintings on same wall
  * Adding table \u2192 Remove existing table or floor items
- Plan REMOVAL of conflicting elements BEFORE adding new product

PHASE 1 - IMAGE SCENE SETUP (Static Elements After Smart Removal):
- FIRST: Remove ALL conflicting elements completely (no traces)
- What objects should EXIST in the initial scene?
- ONLY add people if explicitly mentioned in user request
- Where should elements be POSITIONED after clearing conflicts?
- What should the environment/lighting LOOK LIKE?

PHASE 2 - VIDEO MOTION (What Changes/Moves):
- What should MOVE during the ${durationSeconds} seconds?
- What ACTIONS should happen?
- What EXPRESSIONS or REACTIONS should change?

EXAMPLE SEPARATION:
- User: "\u0642\u0637\u0629 \u062A\u062C\u0631\u064A \u062B\u0645 \u062A\u0642\u0641 \u0639\u0644\u064A \u0627\u0644\u0643\u0646\u0628\u0629 \u0648\u062A\u0628\u0635 \u0644\u0644\u0646\u062C\u0641\u0629 \u0628\u0623\u0646\u0628\u0647\u0627\u0631"
- PHASE 1 (Static): Cat positioned in scene, sofa visible, chandelier prominent in frame
- PHASE 2 (Motion): Cat runs from starting point \u2192 stops on sofa \u2192 looks up at chandelier with amazement expression

\u{1F6A8} MANDATORY QUALITY RULES - PHOTOREALISTIC CGI:
- ALL LIVING CREATURES (people, animals) must have PERFECT NATURAL PROPORTIONS
- NO DISTORTION: Faces, bodies, limbs must be anatomically correct
- ANIMALS must look EXACTLY like real animals (proper head size, body shape, fur texture)
- PEOPLE must have natural human proportions (normal head-to-body ratio, realistic facial features)
- NO MELTING, MORPHING, or UNNATURAL BLENDING of elements
- Each element should appear as if photographed in real life, not artificial or cartoon-like
- SHARP FOCUS and HIGH DETAIL for all elements
- Professional CGI quality comparable to Hollywood film standards

UNIVERSAL REQUEST INTERPRETATION RULES FOR VIDEO:
1. ANY request from the user MUST be implemented literally in the final video
2. If user asks to ADD something \u2192 ADD it visibly and clearly in the video
3. If user asks to CHANGE something \u2192 CHANGE it exactly as requested
4. If user asks to REMOVE something \u2192 COMPLETELY ELIMINATE it with no traces remaining from the video
5. If user specifies QUANTITIES \u2192 Use exact numbers (not approximate)
6. If user specifies POSITIONS \u2192 Place elements exactly where requested in the video
7. If user mentions COLORS \u2192 Apply those exact colors in the video
8. If user describes EMOTIONS/EXPRESSIONS \u2192 Show them clearly on faces throughout the video
9. NEVER interpret requests as "abstract concepts" - make them VISIBLE and CONCRETE in the video
10. \u{1F6A8} CRITICAL: NEVER add people, humans, or characters unless EXPLICITLY mentioned in user request
11. \u{1F6A8} DEFAULT SCENE: Product + Environment ONLY (no people unless requested)

CRITICAL ARABIC LANGUAGE SUPPORT: The user request might be in Arabic. You MUST understand and interpret Arabic properly:

ARABIC PHRASES FOR PEOPLE AND OBJECTS:
- "\u0623\u0636\u0641 \u0646\u0627\u0633 \u0645\u0646\u0628\u0647\u0631\u064A\u0646 \u0628\u0627\u0644\u0645\u0646\u062A\u062C" / "\u0636\u064A\u0641 \u0646\u0627\u0633 \u0645\u0646\u0628\u0647\u0631\u064A\u0646 \u0628\u0627\u0644\u0645\u0646\u062A\u062C" = "Add people amazed by the product" \u2192 MANDATORY: Include actual human figures (2-4 people) in the video scene with visible expressions of amazement, wonder, or admiration while looking at or interacting with the product. Do NOT interpret this metaphorically.
- "\u0623\u0636\u0641 \u0623\u0634\u062E\u0627\u0635 \u0645\u0646\u0628\u0647\u0631\u064A\u0646 \u0628\u0627\u0644\u0645\u0646\u062A\u062C" = "Add people amazed by the product" \u2192 MANDATORY: Same as above, include actual human people showing amazement, NOT just visual storytelling
- "\u0644\u0627 \u062A\u0636\u064A\u0641 \u0623\u0634\u062E\u0627\u0635" / "\u0628\u062F\u0648\u0646 \u0646\u0627\u0633" / "\u0645\u0627 \u0641\u064A \u0646\u0627\u0633" = "Don't add people" / "Without people" \u2192 Do NOT include any human figures
- "\u0634\u062E\u0635 \u0648\u0627\u062D\u062F" / "\u0648\u0627\u062D\u062F \u0645\u0646\u0628\u0647\u0631" = "one person" \u2192 Include exactly 1 person
- "\u0634\u062E\u0635\u064A\u0646" / "\u0627\u062B\u0646\u064A\u0646 \u0645\u0646\u0628\u0647\u0631\u064A\u0646" = "two people" \u2192 Include exactly 2 people
- "\u062B\u0644\u0627\u062B\u0629 \u0623\u0634\u062E\u0627\u0635" / "\u062B\u0644\u0627\u062B \u0646\u0627\u0633" = "three people" \u2192 Include exactly 3 people
- "\u0623\u0631\u0628\u0639\u0629" / "\u0623\u0631\u0628\u0639 \u0623\u0634\u062E\u0627\u0635" = "four people" \u2192 Include exactly 4 people
- "\u062E\u0645\u0633\u0629" / "\u062E\u0645\u0633 \u0623\u0634\u062E\u0627\u0635" = "five people" \u2192 Include exactly 5 people
- "\u0643\u062A\u064A\u0631 \u0646\u0627\u0633" / "\u0646\u0627\u0633 \u0643\u062B\u064A\u0631\u0629" = "many people" \u2192 Include 5+ people in background

ARABIC VIDEO DIRECTION PHRASES:
- "\u0623\u0636\u0641 \u062D\u0631\u0643\u0629 \u0644\u0644\u0643\u0627\u0645\u064A\u0631\u0627" = "Add camera movement" \u2192 Include smooth camera motion
- "\u0632\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0645\u0646\u062A\u062C" = "Zoom on the product" \u2192 Focus closer on the product
- "\u0627\u0639\u0631\u0636 \u0627\u0644\u0645\u0646\u062A\u062C \u0645\u0646 \u0643\u0644 \u0627\u0644\u062C\u0647\u0627\u062A" = "Show the product from all sides" \u2192 360-degree or orbital camera movement
- "\u062E\u0644\u064A\u0647 \u064A\u062A\u062D\u0631\u0643 \u0628\u0628\u0637\u0621" = "Make it move slowly" \u2192 Slow, cinematic camera movement
- "\u0623\u0636\u0641 \u062D\u0631\u0643\u0629 \u0633\u0631\u064A\u0639\u0629" = "Add fast movement" \u2192 Dynamic, energetic camera work
- "\u0627\u0639\u0645\u0644 \u0641\u064A\u062F\u064A\u0648 \u0645\u062B\u064A\u0631" = "Make an exciting video" \u2192 Dramatic camera movements and transitions
- "\u062E\u0644\u064A\u0647 \u064A\u0628\u0627\u0646 \u0623\u062D\u0633\u0646" = "Make it look better" \u2192 Enhance visual appeal through camera work
- "\u0644\u0627 \u062A\u062D\u0631\u0643 \u0627\u0644\u0643\u0627\u0645\u064A\u0631\u0627 \u0643\u062B\u064A\u0631" / "\u0628\u062F\u0648\u0646 \u062D\u0631\u0643\u0629 \u0633\u0631\u064A\u0639\u0629" = "Don't move camera too much" / "Without fast movement" \u2192 Use minimal, smooth movements
- "\u0627\u0628\u062F\u0623 \u0645\u0646 \u0628\u0639\u064A\u062F" = "Start from far" \u2192 Begin with wide shot
- "\u0627\u0642\u0631\u0628 \u0641\u064A \u0627\u0644\u0646\u0647\u0627\u064A\u0629" = "Get close at the end" \u2192 End with close-up shot

IMPORTANT VIDEO INTERPRETATION RULES:
1. CHECK FOR NEGATION FIRST: Words like "\u0644\u0627" / "\u0628\u062F\u0648\u0646" / "\u0645\u0627 \u0641\u064A" mean DO NOT include that element
2. If user mentions "\u0646\u0627\u0633" or "\u0623\u0634\u062E\u0627\u0635" (people) WITHOUT negation, MANDATORY: include actual human figures in the video - DO NOT interpret this as mood, atmosphere, or visual storytelling
3. If user mentions "\u0645\u0646\u0628\u0647\u0631" or "\u0645\u0639\u062C\u0628" (amazed/impressed), show people with expressions of wonder, surprise, or admiration
4. When adding people, use EXACT quantities if specified (\u0634\u062E\u0635\u064A\u0646 = exactly 2 people)
5. If user mentions camera-related Arabic words like "\u0643\u0627\u0645\u064A\u0631\u0627" (camera) or "\u062A\u0635\u0648\u064A\u0631" (filming), focus on camera movements
6. If user mentions speed like "\u0628\u0637\u0621" (slow) or "\u0633\u0631\u064A\u0639" (fast), adjust the pacing accordingly
7. If user mentions showing "\u0645\u0646 \u0643\u0644 \u0627\u0644\u062C\u0647\u0627\u062A" (from all sides), suggest orbital or multi-angle shots
8. Translate the EMOTION and ENERGY level, not just literal words
9. NEVER interpret people requests as "visual storytelling" or "mood" - they mean literal human figures
10. ALWAYS output your response in ENGLISH, even if the input is Arabic

\u{1F3AF} MANDATORY OUTPUT FORMAT - STRICT JSON ONLY:
You must respond with VALID JSON in this exact format:

{
  "imageScenePrompt": "Description of STATIC elements for initial scene - objects, people positions, lighting, environment",
  "videoMotionPrompt": "Description of MOTION/ANIMATION only - what moves, changes, reacts during the ${durationSeconds} seconds",
  "combinedVideoPrompt": "Professional video brief with action verbs: Begin with, Move camera, Show, Focus on, End with",
  "qualityNegativePrompt": "Comma-separated list of things to avoid: deformed, distorted, unnatural proportions, melting, morphing",
  "motionInstructions": "Specific motion timing and camera work details"
}

\u{1F6A8} CRITICAL QUALITY REQUIREMENTS (Include in qualityNegativePrompt):
- For PEOPLE: "deformed faces, distorted body proportions, extra limbs, malformed anatomy, unnatural head size"
- For ANIMALS: "distorted animal anatomy, unnatural proportions, melting fur, deformed limbs, wrong body shape"  
- For ELEMENT CONFLICTS: "overlapping objects, floating objects, conflicting elements, objects occupying same space, duplicate furniture, multiple chandeliers, multiple of same object"
- GENERAL: "blurry, low quality, amateur CGI, morphing, melting, unnatural blending, poor object removal, incomplete element deletion, traces of removed objects"

RESPOND ONLY WITH VALID JSON - NO OTHER TEXT BEFORE OR AFTER THE JSON
`;
    const contentParts = [];
    contentParts.push({
      inlineData: {
        data: productImageData.base64,
        mimeType: productImageData.mimeType
      }
    });
    if (sceneImageData) {
      contentParts.push({
        inlineData: {
          data: sceneImageData.base64,
          mimeType: sceneImageData.mimeType
        }
      });
    }
    contentParts.push(prompt);
    const result = await model.generateContent(contentParts);
    const response = await result.response;
    const fullResponse = response.text();
    let parsedResponse = {};
    try {
      const jsonMatch = fullResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        parsedResponse = JSON.parse(jsonMatch[0]);
        console.log("Successfully parsed Gemini JSON response:", {
          hasImageScene: !!parsedResponse.imageScenePrompt,
          hasVideoMotion: !!parsedResponse.videoMotionPrompt,
          hasCombined: !!parsedResponse.combinedVideoPrompt,
          hasNegativePrompt: !!parsedResponse.qualityNegativePrompt
        });
      } else {
        throw new Error("No JSON found in response");
      }
    } catch (parseError) {
      console.warn("Failed to parse Gemini JSON response, falling back to text parsing:", parseError);
      const imageSceneMatch = fullResponse.match(/imageScenePrompt['"]\s*:\s*['"]([^'"]*)['"]/);
      const videoMotionMatch = fullResponse.match(/videoMotionPrompt['"]\s*:\s*['"]([^'"]*)['"]/);
      const combinedPromptMatch = fullResponse.match(/combinedVideoPrompt['"]\s*:\s*['"]([^'"]*)['"]/);
      parsedResponse = {
        imageScenePrompt: imageSceneMatch ? imageSceneMatch[1] : "",
        videoMotionPrompt: videoMotionMatch ? videoMotionMatch[1] : "",
        combinedVideoPrompt: combinedPromptMatch ? combinedPromptMatch[1] : fullResponse,
        qualityNegativePrompt: "deformed, distorted, unnatural proportions, melting, morphing",
        // Default
        motionInstructions: ""
      };
    }
    const imageScenePrompt = parsedResponse.imageScenePrompt || "";
    const videoMotionPrompt = parsedResponse.videoMotionPrompt || "";
    const combinedVideoPrompt = parsedResponse.combinedVideoPrompt || fullResponse;
    const qualityNegativePrompt = parsedResponse.qualityNegativePrompt || "deformed, distorted, unnatural proportions";
    const enhancedPrompt = combinedVideoPrompt;
    const cameraMovementMatch = fullResponse.match(/camera[^.]*?(pan|zoom|dolly|orbit|push|pull|tilt|track)[^.]*\./i);
    const cameraMovement = cameraMovementMatch ? cameraMovementMatch[0] : void 0;
    const shotListMatch = fullResponse.match(/(\d+-\d+s:|wide|medium|close|establishing|detail)[^.]*\./gi);
    const shotList = shotListMatch ? shotListMatch.join(" \u2192 ") : void 0;
    console.log("Enhanced video prompt generated with separation:", {
      fullResponseLength: fullResponse.length,
      imageSceneLength: imageScenePrompt.length,
      videoMotionLength: videoMotionPrompt.length,
      combinedPromptLength: combinedVideoPrompt.length,
      duration: durationSeconds,
      cameraMovement: cameraMovement?.substring(0, 100),
      shotList: shotList?.substring(0, 100)
    });
    return {
      enhancedPrompt,
      cameraMovement,
      shotList,
      imageScenePrompt,
      // NEW: Static scene description
      videoMotionPrompt,
      // NEW: Motion-only description
      qualityNegativePrompt
      // NEW: Anti-distortion negative prompt
    };
  } catch (error) {
    console.error("Gemini Video Prompt Enhancement error:", error);
    const duration = options.duration || 5;
    const fallbackPrompt = `Professional cinematic ${duration}-second video showcasing the product in the scene. Begin with an establishing shot, then smoothly ${duration <= 5 ? "zoom in to highlight product details" : "move around the product with dynamic camera work"}, ending with a hero shot. Use smooth camera movements, professional lighting, and commercial video quality. ${userDescription}`;
    return {
      enhancedPrompt: fallbackPrompt,
      cameraMovement: duration <= 5 ? "Smooth zoom-in focus" : "Dynamic orbital movement",
      shotList: duration <= 5 ? "Wide \u2192 Close-up" : "Wide \u2192 Medium \u2192 Close-up \u2192 Hero"
    };
  }
}
async function enhanceVideoPromptFromGeneratedImage(generatedImageData, projectDetails) {
  try {
    console.log("\u{1F3AC} Gemini Video Enhancement from Generated Image:", {
      imageSize: generatedImageData.base64.length,
      mimeType: generatedImageData.mimeType,
      duration: projectDetails.duration,
      includeAudio: projectDetails.includeAudio,
      userDescription: projectDetails.userDescription.substring(0, 50) + "..."
    });
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const durationSeconds = projectDetails.duration;
    const isShortVideo = durationSeconds <= 5;
    const prompt = `
\u0627\u0646\u062A \u062E\u0628\u064A\u0631 cgi \u{1F3AF} \u0642\u0645 \u0628\u0639\u0645\u0644 \u0628\u0631\u0648\u0645\u0628\u064A\u062A \u0644\u062A\u062D\u0648\u064A\u0644 \u0647\u0630\u0647 \u0627\u0644\u0635\u0648\u0631\u0629 \u0627\u0644\u062B\u0627\u0628\u062A\u0629 \u0627\u0644\u064A \u0635\u0648\u0631\u0629 \u0645\u062A\u062D\u0631\u0643\u0629 \u0648\u0630\u0644\u0643 \u0639\u0646 \u0637\u0631\u064A\u0642 \u0645\u0648\u0642\u0639 kling 

\u0627\u0644\u0628\u062F\u0627\u064A\u0629 \u0644\u0627\u0632\u0645 \u062A\u062D\u0644\u0644 \u0627\u0644\u0635\u0648\u0631\u0629 \u0643\u0648\u064A\u0633 \u062C\u062F\u0627 \u0648\u062A\u0639\u0631\u0641 \u0627\u064A\u0647 \u0647\u064A \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0628\u0627\u0644\u0638\u0628\u0637 \u0648\u062A\u0631\u0643\u0632 \u0639\u0644\u064A \u0627\u0644\u0639\u0646\u0635\u0631 \u0627\u0644\u0645\u0647\u0645 \u0641\u064A \u0627\u0644\u0635\u0648\u0631\u0629 \u0627\u0644\u064A \u0647\u0648 \u0627\u0643\u0628\u0631 \u0639\u0646\u0635\u0631

\u0645\u0639 \u0645\u0631\u0627\u0639\u0627\u0647 \u0637\u0644\u0628 \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645: "${projectDetails.userDescription}" \u0644\u0648 \u0647\u0648 \u0639\u0627\u064A\u0632 \u064A\u0636\u064A\u0641 \u0634\u064A\u0621 \u0644\u0644\u0641\u064A\u062F\u064A\u0648

\u0643\u062A\u0627\u0628\u0629 \u0627\u0644\u0628\u0631\u0648\u0645\u0628\u064A\u062A \u064A\u0643\u0648\u0646 \u0643\u0627\u0644\u062A\u0644\u064A \u0627\u0639\u062F\u0627\u062F \u0627\u0644\u0645\u0634\u0647\u062F:
- \u0627\u064A\u0647 \u0627\u0644\u0644\u064A \u064A\u062A\u062D\u0631\u0643 \u062E\u0644\u0627\u0644 \u0627\u0644\u0640${durationSeconds} \u062B\u0648\u0627\u0646\u064A\u061F
- \u0627\u064A\u0647 \u0627\u0644\u0627\u0643\u0634\u0646 \u0627\u0644\u0644\u064A \u064A\u062D\u0635\u0644\u061F
- \u0627\u064A\u0647 \u0627\u0644\u062A\u0639\u0628\u064A\u0631\u0627\u062A \u0627\u0644\u0644\u064A \u062A\u062A\u063A\u064A\u0631\u061F
- \u0627\u0644\u0643\u0627\u0645\u064A\u0631\u0627 \u062A\u0643\u0648\u0646 \u0627\u0630\u0627\u064A \u0643\u0644 \u0634\u064A\u0621 \u0628\u064A\u062A\u0645 \u0627\u0630\u0627\u064A \u0628\u0627\u0644\u0638\u0628\u0637

\u0628\u0645\u0639\u0646\u064A \u0627\u0646\u062A \u0643\u062E\u0628\u064A\u0631 cgi \u0644\u0627\u0632\u0645 \u062A\u0648\u0636\u062D \u0643\u0644 \u0634\u064A\u0621 \u0628\u0627\u0644\u0643\u0627\u0645\u0644 \u0639\u0634\u0627\u0646 \u064A\u062D\u0648\u0644 \u0627\u0644\u0635\u0648\u0631\u0629 \u0627\u0644\u062B\u0627\u0628\u062A\u0647 \u062F\u064A \u0644\u0635\u0648\u0631\u0629 \u0645\u062A\u062D\u0631\u0643\u0629 \u0628\u0647\u062F\u0641 \u0627\u0633\u062A\u0639\u0627\u0631\u0636 \u0627\u0644\u0645\u0646\u062A\u062C \u0627\u0644\u0643\u0628\u064A\u0631 \u0628\u0634\u0643\u0644 \u062C\u064A\u062F \u0648\u062C\u0645\u064A\u0644 

\u{1F6A8} \u0642\u0648\u0627\u0639\u062F \u0627\u0644\u062C\u0648\u062F\u0629 \u0627\u0644\u0627\u062C\u0628\u0627\u0631\u064A\u0629 - CGI \u0641\u0648\u062A\u0648\u0631\u064A\u0644\u064A\u0633\u062A\u0643:
- \u0643\u0644 \u0627\u0644\u0643\u0627\u0626\u0646\u0627\u062A \u0627\u0644\u062D\u064A\u0629 \u0627\u0630\u0627 \u0648\u062C\u062F\u062A \u0644\u0627\u0632\u0645 \u062A\u0643\u0648\u0646 \u0628\u0646\u0633\u0628 \u0637\u0628\u064A\u0639\u064A\u0629 \u0645\u062B\u0627\u0644\u064A\u0629
- \u0645\u0645\u0646\u0648\u0639 \u0627\u0644\u062A\u0634\u0648\u064A\u0647: \u0627\u0644\u0648\u0634\u0648\u0634 \u0648\u0627\u0644\u0627\u062C\u0633\u0627\u0645 \u0644\u0627\u0632\u0645 \u062A\u0643\u0648\u0646 \u0635\u062D \u062A\u0634\u0631\u064A\u062D\u064A\u0627\u064B

\u{1F3AF} \u0627\u062E\u0631\u062C \u0627\u0644\u0631\u062F \u0628\u0635\u064A\u063A\u0629 JSON \u0635\u062D\u064A\u062D\u0629:
{
  "imageScenePrompt": "\u0648\u0635\u0641 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u062B\u0627\u0628\u062A\u0629",
  "videoMotionPrompt": "\u0648\u0635\u0641 \u0627\u0644\u062D\u0631\u0643\u0629 \u0628\u0633",
  "combinedVideoPrompt": "\u0627\u0644\u0628\u0631\u0648\u0645\u0628\u062A \u0627\u0644\u0645\u062A\u0643\u0627\u0645\u0644",
  "qualityNegativePrompt": "\u0627\u0644\u0627\u0634\u064A\u0627\u0621 \u0627\u0644\u0644\u064A \u0646\u062A\u062C\u0646\u0628\u0647\u0627",
  "motionInstructions": "\u062A\u0641\u0627\u0635\u064A\u0644 \u0627\u0644\u062A\u0648\u0642\u064A\u062A \u0648\u0627\u0644\u0643\u0627\u0645\u064A\u0631\u0627"
}
`;
    console.log("\u{1F916} Sending analysis request to Gemini...");
    const result = await model.generateContent([
      {
        inlineData: {
          data: generatedImageData.base64,
          mimeType: generatedImageData.mimeType
        }
      },
      prompt
    ]);
    const response = await result.response;
    const text2 = response.text();
    console.log("\u2705 Gemini video analysis complete:", {
      responseLength: text2.length,
      containsJSON: text2.includes("{") && text2.includes("}"),
      containsVideoMotionPrompt: text2.includes("videoMotionPrompt"),
      containsCombinedPrompt: text2.includes("combinedVideoPrompt")
    });
    let parsedResponse = {};
    try {
      const jsonMatch = text2.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        parsedResponse = JSON.parse(jsonMatch[0]);
        console.log("Successfully parsed Gemini JSON video response:", {
          hasImageScene: !!parsedResponse.imageScenePrompt,
          hasVideoMotion: !!parsedResponse.videoMotionPrompt,
          hasCombined: !!parsedResponse.combinedVideoPrompt,
          hasMotionInstructions: !!parsedResponse.motionInstructions
        });
      } else {
        throw new Error("No JSON found in response");
      }
    } catch (parseError) {
      console.warn("Failed to parse Gemini JSON video response, using text fallback:", parseError);
      parsedResponse = {
        combinedVideoPrompt: text2,
        motionInstructions: `${durationSeconds}-second video with smooth camera movement`,
        videoMotionPrompt: text2
      };
    }
    const cameraMovements = parsedResponse.motionInstructions || `Smooth ${durationSeconds}-second camera movement showcasing the product with cinematic flow`;
    const cinematicDirection = parsedResponse.videoMotionPrompt || `Professional ${durationSeconds}-second product showcase with dynamic visual progression`;
    const audioPrompt = projectDetails.includeAudio ? "Natural ambient environmental sounds matching the scene atmosphere with subtle product-related audio effects" : void 0;
    const enhancedVideoPrompt = parsedResponse.combinedVideoPrompt || `
PROFESSIONAL CGI VIDEO GENERATION:

\u{1F3AC} CINEMATOGRAPHY:
${cameraMovements}

\u{1F3AD} VISUAL NARRATIVE:
${cinematicDirection}

\u23F1\uFE0F TIMING: ${durationSeconds} seconds
\u{1F3AF} FOCUS: Maintain product prominence throughout the sequence
\u{1F4AB} QUALITY: Ultra-realistic CGI with seamless motion and perfect lighting continuity
\u{1F4D0} ASPECT: Professional composition with balanced framing
\u2728 STYLE: Cinematic, commercial-grade video production

TECHNICAL REQUIREMENTS:
- Smooth, professional camera work
- Consistent lighting and shadows
- Natural product movement within scene
- High-resolution output (1080p minimum)
- Fluid ${durationSeconds}-second duration
- Commercial-quality post-production feel
`;
    console.log("\u{1F3AC} Video prompt enhancement completed:", {
      enhancedPromptLength: enhancedVideoPrompt.length,
      audioIncluded: !!audioPrompt,
      cameraMovementsLength: cameraMovements.length,
      cinematicDirectionLength: cinematicDirection.length
    });
    return {
      enhancedVideoPrompt,
      audioPrompt,
      cameraMovements,
      cinematicDirection
    };
  } catch (error) {
    console.error("\u274C Gemini video enhancement error:", error);
    const fallbackCameraMovement = projectDetails.duration <= 5 ? "Smooth 5-second product focus with subtle camera push-in and gentle rotation" : "Dynamic 10-second sequence with opening wide shot, smooth dolly movement, and close-up product showcase finale";
    const fallbackVideoPrompt = `
Professional CGI video: ${fallbackCameraMovement}. 
Ultra-realistic ${projectDetails.duration}-second commercial-quality sequence showcasing the product.
Cinematic lighting, smooth motion, high-resolution output.
${projectDetails.userDescription}
`;
    return {
      enhancedVideoPrompt: fallbackVideoPrompt,
      audioPrompt: projectDetails.includeAudio ? "Natural ambient environmental sounds matching the scene atmosphere with subtle product-related audio effects" : void 0,
      cameraMovements: fallbackCameraMovement,
      cinematicDirection: `Professional ${projectDetails.duration}-second product showcase sequence`
    };
  }
}
var genAI;
var init_gemini = __esm({
  "server/services/gemini.ts"() {
    "use strict";
    genAI = new GoogleGenerativeAI(
      process.env.GEMINI_API_KEY || ""
    );
  }
});

// server/services/kling-video.ts
var kling_video_exports = {};
__export(kling_video_exports, {
  generateVideoWithKling: () => generateVideoWithKling
});
import { randomUUID } from "crypto";
function getTaskId(response, correlationId) {
  console.log(`\u{1F50D} [${correlationId}] Extracting task_id from response:`, {
    responseType: typeof response,
    hasData: response && typeof response === "object" && "data" in response,
    responseKeys: response && typeof response === "object" ? Object.keys(response) : null
  });
  let currentData = response;
  let parseAttempts = 0;
  const maxParseAttempts = 3;
  while (typeof currentData === "string" && parseAttempts < maxParseAttempts) {
    try {
      const parsed = JSON.parse(currentData);
      console.log(`\u{1F50D} [${correlationId}] Parsed JSON string (attempt ${parseAttempts + 1}):`, {
        originalLength: currentData.length,
        parsedType: typeof parsed,
        parsedKeys: parsed && typeof parsed === "object" ? Object.keys(parsed) : null
      });
      currentData = parsed;
      parseAttempts++;
    } catch (e) {
      console.log(`\u{1F50D} [${correlationId}] Failed to parse as JSON (attempt ${parseAttempts + 1}):`, {
        data: currentData.substring(0, 100),
        error: e
      });
      break;
    }
  }
  const finalData = currentData && typeof currentData === "object" && currentData.data ? currentData.data : currentData;
  console.log(`\u{1F50D} [${correlationId}] Final data object for task_id extraction:`, {
    finalDataType: typeof finalData,
    finalDataKeys: finalData && typeof finalData === "object" ? Object.keys(finalData) : null,
    hasDataWrapper: !!(currentData && typeof currentData === "object" && currentData.data)
  });
  const possiblePaths = [
    finalData?.task_id,
    // Standard: data.task_id
    finalData?.taskId,
    // Camel case variant
    finalData?.task?.task_id,
    // Nested: data.task.task_id
    finalData?.task?.id,
    // Nested: data.task.id
    finalData?.id,
    // Simple: data.id
    currentData?.task_id,
    // Direct on original response
    currentData?.taskId
    // Direct camelCase on original response
  ];
  for (let i = 0; i < possiblePaths.length; i++) {
    const taskId = possiblePaths[i];
    if (taskId && (typeof taskId === "string" || typeof taskId === "number") && String(taskId).length > 0) {
      const finalTaskId = String(taskId);
      console.log(`\u2705 [${correlationId}] Found task_id at path ${i}:`, { taskId: finalTaskId, path: i, originalType: typeof taskId });
      return finalTaskId;
    }
  }
  console.log(`\u274C [${correlationId}] No task_id found in any expected location:`, {
    possiblePaths: possiblePaths.map((p, i) => ({ index: i, value: p, type: typeof p })),
    finalDataKeys: finalData && typeof finalData === "object" ? Object.keys(finalData) : null,
    finalDataType: typeof finalData,
    parseAttempts
  });
  return null;
}
async function addAudioToVideo(videoTaskId, prompt, klingApiKey, projectId, storage2) {
  const correlationId = randomUUID().substring(0, 8);
  console.log(`\u{1F527} [${correlationId}] VERSION 2.1.0 - Adding audio to video via PiAPI Kling Sound...`, {
    videoTaskId,
    prompt: prompt.substring(0, 50) + "...",
    correlationId
  });
  const audioRequestPayload = {
    model: "kling",
    task_type: "sound",
    input: {
      origin_task_id: videoTaskId
      // Use the video generation task ID, not video URL
    }
  };
  const response = await fetch("https://api.piapi.ai/api/v1/task", {
    method: "POST",
    headers: {
      "X-API-Key": klingApiKey,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(audioRequestPayload)
  });
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Kling Sound API error:", {
      status: response.status,
      statusText: response.statusText,
      error: errorText
    });
    throw new Error(`Kling Sound API error: ${response.status} - ${errorText}`);
  }
  const rawBody = await response.clone().text();
  console.log(`\u{1F50D} [${correlationId}] Raw Kling Sound API response:`, {
    contentType: response.headers.get("content-type"),
    bodyLength: rawBody.length,
    bodyPreview: rawBody.substring(0, 200) + (rawBody.length > 200 ? "..." : "")
  });
  const result = await response.json();
  const taskId = getTaskId(result, correlationId);
  console.log(`\u2705 [${correlationId}] Kling Sound request submitted:`, {
    taskId,
    status: result?.data?.status || result?.status,
    hasTaskId: !!taskId,
    responseFormat: result.data ? "wrapped" : "direct"
  });
  if (!taskId) {
    console.error(`\u274C CRITICAL [${correlationId}] Kling Sound API didn't return a task_id!`, {
      fullResponse: JSON.stringify(result, null, 2),
      rawBodyPreview: rawBody.substring(0, 500)
    });
    throw new Error(`Kling Sound API error: No task_id returned. Response: ${JSON.stringify(result)}`);
  }
  if (projectId && storage2) {
    try {
      await storage2.updateProject(projectId, {
        klingSoundTaskId: taskId
      });
      console.log("\u2705 RECOVERY: Saved Kling audio task ID for recovery:", {
        projectId,
        soundTaskId: taskId,
        saved: "immediately"
      });
    } catch (saveError) {
      console.error("\u26A0\uFE0F WARNING: Failed to save audio task ID for recovery (continuing anyway):", {
        projectId,
        soundTaskId: taskId,
        error: saveError instanceof Error ? saveError.message : "Unknown error"
      });
    }
  } else {
    console.log("\u2139\uFE0F RECOVERY: No project/storage provided - audio task ID not saved for recovery:", {
      hasProjectId: !!projectId,
      hasStorage: !!storage2,
      soundTaskId: taskId
    });
  }
  let attempts = 0;
  const maxAttempts = 30;
  while (attempts < maxAttempts) {
    await new Promise((resolve) => setTimeout(resolve, 1e4));
    attempts++;
    console.log(`Checking Kling Sound status, attempt ${attempts}/${maxAttempts}...`);
    const statusResponse = await fetch(`https://api.piapi.ai/api/v1/task/${taskId}`, {
      headers: {
        "X-API-Key": klingApiKey
      }
    });
    if (!statusResponse.ok) {
      console.error("Failed to check Kling Sound status:", statusResponse.status);
      if (attempts > 5 && (statusResponse.status === 400 || statusResponse.status === 404)) {
        console.error(`Persistent Sound API errors (${statusResponse.status}) after ${attempts} attempts - giving up`);
        throw new Error(`Kling Sound status check failed: HTTP ${statusResponse.status} after ${attempts} attempts`);
      }
      continue;
    }
    const statusResult = await statusResponse.json();
    console.log("Kling Sound status update:", {
      status: statusResult.status,
      progress: statusResult.progress || "N/A"
    });
    if (statusResult.status === "completed" || statusResult.status === "success") {
      console.log("Kling Sound generation completed!");
      const videoWithAudioUrl = statusResult.output?.video_url || statusResult.output?.works?.[0]?.video?.resource_without_watermark || statusResult.output?.works?.[0]?.video?.resource;
      if (!videoWithAudioUrl) {
        console.error("No video URL found in audio completion result:", statusResult);
        throw new Error("Video with audio URL not found in Kling Sound response");
      }
      console.log("Audio added to video successfully:", {
        originalVideoTaskId: videoTaskId,
        videoWithAudioUrl,
        attempts
      });
      return videoWithAudioUrl;
    }
    if (statusResult.status === "failed" || statusResult.status === "error") {
      console.error("Kling Sound generation failed:", statusResult);
      throw new Error(`Kling Sound generation failed: ${statusResult.error || "Unknown error"}`);
    }
    if (statusResult.status === "processing" || statusResult.status === "pending" || statusResult.status === "running") {
      console.log(`Kling Sound still processing... (${statusResult.progress || "N/A"})`);
      continue;
    }
  }
  throw new Error(`Kling Sound generation timed out after ${maxAttempts * 10} seconds`);
}
async function generateVideoWithKling(imageUrl, prompt, durationSeconds = 10, includeAudio = false, negativePrompt = "", projectId, storage2) {
  const correlationId = randomUUID().substring(0, 8);
  console.log(`\u{1F3AC} [${correlationId}] VERSION 2.1.0 - Starting Kling AI video generation...`, {
    imageUrl,
    prompt: prompt.substring(0, 100) + "...",
    duration: durationSeconds,
    correlationId
  });
  try {
    console.log("\u{1F310} Using direct image URL for Kling API:", imageUrl);
    if (!imageUrl || !imageUrl.startsWith("http://") && !imageUrl.startsWith("https://")) {
      throw new Error(`Invalid image URL: ${imageUrl}`);
    }
    console.log("\u2705 Direct URL approach - skipping image processing:", {
      imageUrl,
      urlLength: imageUrl.length,
      approach: "direct_url",
      payloadSize: "minimal"
    });
    const klingApiKey = process.env.KLING_API_KEY;
    if (!klingApiKey) {
      throw new Error("KLING_API_KEY environment variable is required");
    }
    const requestPayload = {
      model: "kling",
      task_type: "video_generation",
      input: {
        prompt,
        image_url: imageUrl,
        // Send direct image URL
        duration: durationSeconds,
        aspect_ratio: "16:9",
        mode: "std",
        // std or pro
        cfg_scale: 0.5,
        // 0.1 to 1.0
        negative_prompt: negativePrompt || "deformed, distorted, unnatural proportions, melting, morphing, blurry, low quality"
      }
    };
    const jsonPayload = JSON.stringify(requestPayload);
    const payloadSizeBytes = Buffer.byteLength(jsonPayload, "utf8");
    console.log("\u{1F680} SENDING REQUEST TO KLING AI VIA PiAPI - USING DIRECT URL METHOD:", {
      model: requestPayload.model,
      task_type: requestPayload.task_type,
      duration: requestPayload.input.duration,
      aspectRatio: requestPayload.input.aspect_ratio,
      imageUrl,
      imageUrlLength: imageUrl.length,
      promptCharacters: prompt.length,
      promptBytes: Buffer.byteLength(prompt, "utf8"),
      payloadSizeBytes,
      payloadSizeKB: Math.round(payloadSizeBytes / 1024),
      METHOD: "DIRECT_URL_NO_BASE64",
      apiEndpoint: "https://api.piapi.ai/api/v1/task"
    });
    if (requestPayload.input.image_url.startsWith("/9j/") || requestPayload.input.image_url.length > 1e3) {
      throw new Error(`\u{1F6A8} CRITICAL: Still sending base64 instead of URL! Length: ${requestPayload.input.image_url.length}`);
    }
    console.log("\u2705 VALIDATION PASSED: Sending direct URL to Kling API:", requestPayload.input.image_url);
    const response = await fetch("https://api.piapi.ai/api/v1/task", {
      method: "POST",
      headers: {
        "X-API-Key": klingApiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestPayload)
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error("Kling AI API error:", {
        status: response.status,
        statusText: response.statusText,
        error: errorText
      });
      throw new Error(`Kling AI API error: ${response.status} - ${errorText}`);
    }
    const rawBody = await response.clone().text();
    console.log(`\u{1F50D} [${correlationId}] Raw Kling AI response:`, {
      contentType: response.headers.get("content-type"),
      bodyLength: rawBody.length,
      bodyPreview: rawBody.substring(0, 200) + (rawBody.length > 200 ? "..." : "")
    });
    const result = await response.json();
    console.log(`\u{1F50D} [${correlationId}] EXACT RESPONSE ANALYSIS:`, {
      result,
      resultType: typeof result,
      resultJSON: JSON.stringify(result, null, 2)
    });
    const taskId = getTaskId(result, correlationId);
    console.log(`\u{1F50D} [${correlationId}] getTaskId RETURNED:`, {
      taskId,
      taskIdType: typeof taskId,
      taskIdLength: taskId ? taskId.length : 0
    });
    console.log(`\u2705 [${correlationId}] Kling AI request submitted successfully:`, {
      taskId,
      status: result?.data?.status || result?.status,
      hasTaskId: !!taskId,
      responseFormat: result.data ? "wrapped" : "direct"
    });
    if (!taskId) {
      console.error(`\u274C CRITICAL [${correlationId}] Kling AI didn't return a task_id!`, {
        fullResponse: JSON.stringify(result, null, 2),
        rawBodyPreview: rawBody.substring(0, 500)
      });
      throw new Error(`Kling AI API error: No task_id returned. Response: ${JSON.stringify(result)}`);
    }
    if (projectId && storage2) {
      try {
        await storage2.updateProject(projectId, {
          klingVideoTaskId: taskId
          // Don't overwrite includeAudio - keep original user choice
        });
        console.log("\u2705 RECOVERY: Saved Kling video task ID for recovery:", {
          projectId,
          taskId,
          includeAudio,
          saved: "immediately"
        });
      } catch (saveError) {
        console.error("\u26A0\uFE0F WARNING: Failed to save task ID for recovery (continuing anyway):", {
          projectId,
          taskId,
          error: saveError instanceof Error ? saveError.message : "Unknown error"
        });
      }
    } else {
      console.log("\u2139\uFE0F RECOVERY: No project/storage provided - task ID not saved for recovery:", {
        hasProjectId: !!projectId,
        hasStorage: !!storage2,
        taskId
      });
    }
    console.log(`\u{1F550} [${correlationId}] Starting 4-minute wait strategy...`, {
      taskId,
      waitTime: "4 minutes (240 seconds)",
      previousStrategy: "60 polling calls = expensive!",
      newStrategy: "single wait + 1 API call = cost efficient!",
      estimatedSavings: "59 API calls saved!"
    });
    await new Promise((resolve) => setTimeout(resolve, 24e4));
    console.log(`\u23F0 [${correlationId}] 4-minute wait completed! Making single status check...`);
    const statusResponse = await fetch(`https://api.piapi.ai/api/v1/task/${taskId}`, {
      headers: {
        "X-API-Key": klingApiKey
      }
    });
    if (!statusResponse.ok) {
      const errorText = await statusResponse.text();
      console.error(`\u274C [${correlationId}] Final status check failed:`, {
        status: statusResponse.status,
        statusText: statusResponse.statusText,
        error: errorText,
        taskId
      });
      throw new Error(`Kling AI final status check failed: HTTP ${statusResponse.status}. Error: ${errorText}`);
    }
    const rawStatusBody = await statusResponse.clone().text();
    console.log(`\u{1F50D} [${correlationId}] Final status response:`, {
      contentType: statusResponse.headers.get("content-type"),
      statusCode: statusResponse.status,
      bodyLength: rawStatusBody.length,
      bodyPreview: rawStatusBody.substring(0, 300) + (rawStatusBody.length > 300 ? "..." : "")
    });
    const statusResult = await statusResponse.json();
    console.log(`\u{1F50D} [${correlationId}] Complete task details:`, {
      resultType: typeof statusResult,
      resultKeys: statusResult && typeof statusResult === "object" ? Object.keys(statusResult) : null,
      taskDetailsSize: JSON.stringify(statusResult).length
    });
    const taskStatus = statusResult?.status || statusResult?.data?.status;
    const taskProgress = statusResult?.progress || statusResult?.data?.progress;
    console.log(`\u2705 [${correlationId}] Final status check result:`, {
      status: taskStatus,
      progress: taskProgress || "N/A",
      extractedFrom: statusResult?.status ? "direct" : statusResult?.data?.status ? "data.status" : "none",
      waitTime: "4 minutes",
      apiCallsUsed: 1
    });
    if (taskStatus === "completed" || taskStatus === "success") {
      console.log(`\u{1F3AC} [${correlationId}] Kling AI video generation completed after 4-minute wait!`);
      const outputData = statusResult.output || statusResult.data?.output;
      const videoUrl = outputData?.video_url || outputData?.works?.[0]?.video?.resource_without_watermark || outputData?.works?.[0]?.video?.resource;
      if (!videoUrl) {
        console.error(`\u274C [${correlationId}] No video URL found in completed result:`, {
          statusResult,
          outputData,
          hasOutput: !!outputData,
          outputKeys: outputData ? Object.keys(outputData) : null
        });
        throw new Error("Video URL not found in Kling AI response");
      }
      console.log(`\u{1F389} [${correlationId}] Kling AI video generation successful:`, {
        videoUrl,
        duration: durationSeconds,
        strategy: "4-minute-wait",
        apiCallsUsed: 1,
        costSavings: "59 API calls saved!"
      });
      let finalVideoUrl = videoUrl;
      if (includeAudio) {
        console.log(`\u{1F50A} [${correlationId}] AUDIO INTEGRATION REQUESTED:`, {
          originalVideoUrl: videoUrl,
          prompt: prompt.substring(0, 100) + "...",
          includeAudio
        });
        try {
          finalVideoUrl = await addAudioToVideo(taskId, prompt, klingApiKey, projectId, storage2);
          console.log(`\u{1F3B5} [${correlationId}] AUDIO ADDED SUCCESSFULLY:`, {
            originalVideoUrl: videoUrl,
            originalVideoTaskId: taskId,
            videoWithAudioUrl: finalVideoUrl,
            audioIntegrationSuccess: true
          });
        } catch (audioError) {
          const errorMessage = audioError instanceof Error ? audioError.message : String(audioError);
          const errorStack = audioError instanceof Error ? audioError.stack : void 0;
          console.error(`\u274C [${correlationId}] AUDIO INTEGRATION FAILED:`, {
            originalVideoUrl: videoUrl,
            audioError: errorMessage,
            audioErrorStack: errorStack,
            fallbackToOriginalVideo: true
          });
        }
      } else {
        console.log(`\u{1F507} [${correlationId}] NO AUDIO REQUESTED - using original video only`);
      }
      return {
        url: finalVideoUrl,
        duration: durationSeconds,
        fullTaskDetails: statusResult
        // NEW: Include complete task details for UI display
      };
    }
    if (taskStatus === "failed" || taskStatus === "error") {
      console.error(`\u274C [${correlationId}] Kling AI generation failed:`, statusResult);
      const errorMessage = statusResult.error || statusResult.data?.error || statusResult.message || statusResult.data?.message || "Unknown error";
      throw new Error(`Kling AI generation failed: ${errorMessage}`);
    }
    if (taskStatus === "processing" || taskStatus === "pending" || taskStatus === "running") {
      console.warn(`\u23F3 [${correlationId}] Video still processing after 4 minutes - this is unusual but can happen for complex videos`);
      throw new Error(`Kling AI generation still processing after 4 minutes. Status: ${taskStatus}. This might need manual checking.`);
    }
    console.error(`\u2753 [${correlationId}] Unexpected Kling AI status after 4 minutes:`, {
      status: taskStatus,
      fullTaskDetails: statusResult
    });
    throw new Error(`Unexpected Kling AI status after 4 minutes: ${taskStatus}`);
  } catch (error) {
    console.error(`\u274C [${correlationId}] Kling AI video generation error:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Kling AI video generation failed: ${errorMessage}`);
  }
}
var init_kling_video = __esm({
  "server/services/kling-video.ts"() {
    "use strict";
  }
});

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  insertJobSchema: () => insertJobSchema,
  insertProjectSchema: () => insertProjectSchema,
  insertTransactionSchema: () => insertTransactionSchema,
  jobQueue: () => jobQueue,
  projects: () => projects,
  sessions: () => sessions,
  transactions: () => transactions,
  users: () => users
});
import { sql } from "drizzle-orm";
import {
  index,
  jsonb,
  pgTable,
  timestamp,
  varchar,
  integer,
  text,
  boolean
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull()
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);
var users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique().notNull(),
  password: varchar("password").notNull(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  credits: integer("credits").default(5).notNull(),
  isAdmin: boolean("is_admin").default(false),
  stripeCustomerId: varchar("stripe_customer_id"),
  stripeSubscriptionId: varchar("stripe_subscription_id"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var projects = pgTable("projects", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  title: varchar("title").notNull(),
  description: text("description"),
  productImageUrl: varchar("product_image_url").notNull(),
  sceneImageUrl: varchar("scene_image_url"),
  // Made nullable to support sceneVideoUrl
  sceneVideoUrl: varchar("scene_video_url"),
  // New: support video scene input
  contentType: varchar("content_type", { enum: ["image", "video"] }).notNull(),
  videoDurationSeconds: integer("video_duration_seconds").default(5),
  // New: 5 or 10 seconds
  status: varchar("status", {
    enum: ["pending", "processing", "enhancing_prompt", "generating_image", "generating_video", "completed", "failed"]
  }).default("pending"),
  progress: integer("progress").default(0),
  enhancedPrompt: text("enhanced_prompt"),
  outputImageUrl: varchar("output_image_url"),
  outputVideoUrl: varchar("output_video_url"),
  creditsUsed: integer("credits_used").notNull(),
  actualCost: integer("actual_cost").default(0).notNull(),
  // in millicents (1/1000 USD)
  resolution: varchar("resolution").default("1024x1024"),
  quality: varchar("quality").default("standard"),
  errorMessage: text("error_message"),
  // Kling AI task tracking for recovery
  klingVideoTaskId: varchar("kling_video_task_id"),
  // For video generation task
  klingSoundTaskId: varchar("kling_sound_task_id"),
  // For audio enhancement task
  includeAudio: boolean("include_audio").default(false),
  // Whether to add audio to video
  // Full task details from Kling AI for UI display (6-minute wait strategy)
  fullTaskDetails: jsonb("full_task_details"),
  // Complete Kling AI task response JSON
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var transactions = pgTable("transactions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  amount: integer("amount").notNull(),
  // in cents
  credits: integer("credits").notNull(),
  stripePaymentIntentId: varchar("stripe_payment_intent_id").unique(),
  // UNIQUE constraint for idempotency
  status: varchar("status", { enum: ["pending", "completed", "failed"] }).default("pending"),
  processedAt: timestamp("processed_at"),
  // When webhook was processed
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var insertProjectSchema = createInsertSchema(projects).pick({
  title: true,
  description: true,
  productImageUrl: true,
  sceneImageUrl: true,
  sceneVideoUrl: true,
  contentType: true,
  videoDurationSeconds: true,
  resolution: true,
  quality: true
}).refine((data) => {
  const hasImage = !!data.sceneImageUrl;
  const hasVideo = !!data.sceneVideoUrl;
  return hasImage !== hasVideo;
}, {
  message: "Provide either scene image or scene video, not both"
});
var insertTransactionSchema = createInsertSchema(transactions).pick({
  amount: true,
  credits: true,
  stripePaymentIntentId: true,
  status: true,
  processedAt: true
});
var jobQueue = pgTable("job_queue", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  type: varchar("type").notNull(),
  // 'cgi_generation'
  status: varchar("status", {
    enum: ["pending", "processing", "completed", "failed"]
  }).default("pending"),
  projectId: varchar("project_id").notNull().references(() => projects.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  priority: integer("priority").notNull().default(0),
  // Higher = more priority
  attempts: integer("attempts").notNull().default(0),
  maxAttempts: integer("max_attempts").notNull().default(3),
  progress: integer("progress").notNull().default(0),
  // 0-100
  statusMessage: text("status_message"),
  errorMessage: text("error_message"),
  data: jsonb("data"),
  // Job-specific data like contentType, paths, etc
  result: jsonb("result"),
  // Final result data
  scheduledFor: timestamp("scheduled_for").defaultNow(),
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var insertJobSchema = createInsertSchema(jobQueue).pick({
  type: true,
  projectId: true,
  userId: true,
  data: true,
  priority: true
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
neonConfig.webSocketConstructor = ws;
neonConfig.poolQueryViaFetch = true;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 5,
  // Reduce max connections to avoid limits
  idleTimeoutMillis: 3e4,
  // 30 seconds idle timeout
  connectionTimeoutMillis: 1e4,
  // 10 seconds connection timeout
  allowExitOnIdle: true
  // Allow pool to exit when idle
});
var db = drizzle({ client: pool, schema: schema_exports });

// server/storage.ts
import { eq, desc, count, and } from "drizzle-orm";
var DatabaseStorage = class {
  // User operations
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByEmail(email) {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }
  async createUser(userData) {
    const [user] = await db.insert(users).values({
      email: userData.email,
      password: userData.password,
      firstName: userData.firstName,
      lastName: userData.lastName,
      credits: userData.credits || 5
    }).returning();
    return user;
  }
  async upsertUser(userData) {
    const [user] = await db.insert(users).values(userData).onConflictDoUpdate({
      target: users.id,
      set: {
        ...userData,
        updatedAt: /* @__PURE__ */ new Date()
      }
    }).returning();
    return user;
  }
  async updateUser(id, updates) {
    await db.update(users).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(users.id, id));
  }
  async updateUserCredits(id, credits) {
    const user = await this.getUser(id);
    if (user && user.email === "admin@test.com") {
      await db.update(users).set({ credits: 1e3, updatedAt: /* @__PURE__ */ new Date() }).where(eq(users.id, id));
    } else {
      await db.update(users).set({ credits, updatedAt: /* @__PURE__ */ new Date() }).where(eq(users.id, id));
    }
  }
  // Project operations
  async createProject(projectData) {
    const [project] = await db.insert(projects).values(projectData).returning();
    return project;
  }
  async getProject(id) {
    const [project] = await db.select().from(projects).where(eq(projects.id, id));
    return project;
  }
  async getUserProjects(userId) {
    return await db.select().from(projects).where(eq(projects.userId, userId)).orderBy(desc(projects.createdAt));
  }
  async updateProject(id, updates) {
    await db.update(projects).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(projects.id, id));
  }
  // Transaction operations
  async createTransaction(transactionData) {
    const [transaction] = await db.insert(transactions).values({
      ...transactionData,
      updatedAt: /* @__PURE__ */ new Date()
      // Ensure updatedAt is set
    }).returning();
    return transaction;
  }
  async getUserTransactions(userId) {
    return await db.select().from(transactions).where(eq(transactions.userId, userId)).orderBy(desc(transactions.createdAt));
  }
  async getTransactionByPaymentIntent(paymentIntentId) {
    const [transaction] = await db.select().from(transactions).where(eq(transactions.stripePaymentIntentId, paymentIntentId));
    return transaction;
  }
  async updateTransaction(id, updates) {
    await db.update(transactions).set({
      ...updates,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(transactions.id, id));
  }
  // Admin operations
  async getAllUsers() {
    return await db.select().from(users).orderBy(desc(users.createdAt));
  }
  async getAllProjects() {
    return await db.select().from(projects).orderBy(desc(projects.createdAt));
  }
  async getPlatformStats() {
    const [userCount] = await db.select({ count: count() }).from(users);
    const [projectCount] = await db.select({ count: count() }).from(projects);
    const [transactionCount] = await db.select({ count: count() }).from(transactions);
    const [completedProjects] = await db.select({ count: count() }).from(projects).where(eq(projects.status, "completed"));
    return {
      totalUsers: userCount?.count || 0,
      totalProjects: projectCount?.count || 0,
      completedProjects: completedProjects?.count || 0,
      totalTransactions: transactionCount?.count || 0
    };
  }
  // Job Queue operations
  async createJob(jobData) {
    const [job] = await db.insert(jobQueue).values(jobData).returning();
    return job;
  }
  async getJob(jobId) {
    const [job] = await db.select().from(jobQueue).where(eq(jobQueue.id, jobId));
    return job;
  }
  async getJobByProjectId(projectId) {
    const [job] = await db.select().from(jobQueue).where(eq(jobQueue.projectId, projectId)).orderBy(desc(jobQueue.createdAt));
    return job;
  }
  async getNextPendingJob() {
    const [job] = await db.select().from(jobQueue).where(eq(jobQueue.status, "pending")).orderBy(desc(jobQueue.priority), jobQueue.createdAt).limit(1);
    return job;
  }
  async claimJob(jobId) {
    const result = await db.update(jobQueue).set({
      status: "processing",
      startedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(and(
      eq(jobQueue.id, jobId),
      eq(jobQueue.status, "pending")
    ));
    return (result.rowCount || 0) > 0;
  }
  async updateJob(jobId, updates) {
    await db.update(jobQueue).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(jobQueue.id, jobId));
  }
  async markJobCompleted(jobId, result) {
    await db.update(jobQueue).set({
      status: "completed",
      result,
      completedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(jobQueue.id, jobId));
  }
  async markJobFailed(jobId, errorMessage) {
    await db.update(jobQueue).set({
      status: "failed",
      errorMessage,
      completedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(jobQueue.id, jobId));
  }
};
var storage = new DatabaseStorage();

// server/auth.ts
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
var JWT_SECRET = process.env.JWT_SECRET || process.env.SESSION_SECRET || "cgi-generator-secret-2024";
function generateToken(userId, email) {
  return jwt.sign(
    { userId, email },
    JWT_SECRET,
    { expiresIn: "7d" }
  );
}
function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    return null;
  }
}
async function hashPassword(password) {
  return bcrypt.hash(password, 12);
}
async function comparePassword(password, hash) {
  return bcrypt.compare(password, hash);
}
var isAuthenticated = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader?.startsWith("Bearer ") ? authHeader.slice(7) : null;
    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }
    const payload = verifyToken(token);
    if (!payload) {
      return res.status(401).json({ message: "Invalid or expired token" });
    }
    req.user = {
      id: payload.userId,
      email: payload.email
    };
    next();
  } catch (error) {
    console.error("Auth middleware error:", error);
    res.status(401).json({ message: "Authentication failed" });
  }
};
async function setupAuth(app2) {
  app2.post("/api/auth/register", async (req, res) => {
    try {
      const { email, password, firstName, lastName } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(409).json({ message: "User already exists" });
      }
      const hashedPassword = await hashPassword(password);
      const user = await storage.createUser({
        email,
        password: hashedPassword,
        firstName,
        lastName,
        credits: 5
        // Free credits
      });
      const token = generateToken(user.id, user.email);
      res.json({
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          credits: user.credits
        },
        token
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ message: "Registration failed" });
    }
  });
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user || !user.password) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      const isValidPassword = await comparePassword(password, user.password);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      const token = generateToken(user.id, user.email);
      res.json({
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          credits: user.credits
        },
        token
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });
  app2.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        credits: user.credits
      });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
}

// server/routes.ts
init_gemini();
import { z } from "zod";
import { promises as fs, createReadStream, existsSync } from "fs";
import Stripe from "stripe";
import path from "path";
import multer from "multer";

// shared/constants.ts
var CREDIT_PACKAGES = {
  tester: { credits: 100, price: 10, name: "Tester" },
  starter: { credits: 250, price: 25, name: "Starter" },
  pro: { credits: 550, price: 50, name: "Pro" },
  business: { credits: 1200, price: 100, name: "Business" }
};
var COSTS = {
  GEMINI_PROMPT_ENHANCEMENT: 2,
  // $0.002 per request (2 millicents)
  GEMINI_IMAGE_GENERATION: 39,
  // $0.039 per request (39 millicents) - CORRECTED!
  GEMINI_VIDEO_ANALYSIS: 3,
  // $0.003 per video analysis (3 millicents)
  VIDEO_GENERATION: 260
  // $0.26 per 5s video (260 millicents) - USER'S ACTUAL COST
};

// server/routes.ts
async function registerRoutes(app2) {
  await setupAuth(app2);
  const upload = multer({
    storage: multer.memoryStorage(),
    limits: {
      fileSize: 10 * 1024 * 1024
      // 10MB limit
    },
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith("image/")) {
        cb(null, true);
      } else {
        cb(new Error("Only image files are allowed"));
      }
    }
  });
  app2.post("/api/upload-product-image", isAuthenticated, upload.single("productImage"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }
      const { v2: cloudinary } = await import("cloudinary");
      cloudinary.config({
        cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
        api_key: process.env.CLOUDINARY_API_KEY,
        api_secret: process.env.CLOUDINARY_API_SECRET
      });
      const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
      const publicId = `user-uploads/${uniqueSuffix}`;
      console.log("Uploading to Cloudinary:", {
        originalName: req.file.originalname,
        fileSize: req.file.size,
        publicId
      });
      const cloudinaryResult = await new Promise((resolve, reject) => {
        cloudinary.uploader.upload_stream(
          {
            resource_type: "auto",
            public_id: publicId,
            quality: "auto:best",
            fetch_format: "auto"
          },
          (error, result) => {
            if (error) {
              console.error("Cloudinary upload error:", error);
              reject(error);
            } else {
              console.log("Cloudinary upload success:", {
                public_id: result.public_id,
                url: result.secure_url,
                format: result.format,
                bytes: result.bytes
              });
              resolve(result);
            }
          }
        ).end(req.file.buffer);
      });
      res.json({
        url: cloudinaryResult.secure_url,
        imageUrl: cloudinaryResult.secure_url,
        publicId: cloudinaryResult.public_id
      });
    } catch (error) {
      console.error("Error uploading file:", error);
      res.status(500).json({ error: "Failed to upload file" });
    }
  });
  app2.put("/api/product-images", isAuthenticated, async (req, res) => {
    try {
      const { productImageURL } = req.body;
      if (!productImageURL) {
        return res.status(400).json({ error: "productImageURL is required" });
      }
      res.status(200).json({
        imageUrl: productImageURL,
        success: true
      });
    } catch (error) {
      console.error("Error setting product image:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/objects/:objectPath(*)", isAuthenticated, async (req, res) => {
    res.status(410).json({
      message: "Objects are now served from Cloudinary. Please use the direct Cloudinary URLs.",
      deprecated: true
    });
  });
  app2.get("/api/files/*", async (req, res) => {
    try {
      const filename = req.params["0"];
      if (!filename || filename.includes("..") || filename.includes("\0") || path.isAbsolute(filename)) {
        return res.status(400).json({ message: "Invalid file path" });
      }
      const privateDir = "/tmp";
      const filePath = path.resolve(path.join(privateDir, filename));
      if (!filePath.startsWith(path.resolve(privateDir))) {
        return res.status(403).json({ message: "Access denied" });
      }
      const pathParts = filename.split("/");
      if (pathParts.length < 2 || pathParts[0] !== "uploads") {
        return res.status(403).json({ message: "Invalid file structure" });
      }
      if (!existsSync(filePath)) {
        return res.status(404).json({ message: "File not found" });
      }
      const ext = path.extname(filename).toLowerCase();
      const mimeTypes = {
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".png": "image/png",
        ".gif": "image/gif",
        ".webp": "image/webp",
        ".mp4": "video/mp4",
        ".webm": "video/webm",
        ".mov": "video/quicktime"
      };
      const contentType = mimeTypes[ext] || "application/octet-stream";
      res.setHeader("Content-Type", contentType);
      res.setHeader("Cache-Control", "private, max-age=3600");
      const fileStream = createReadStream(filePath);
      fileStream.pipe(res);
    } catch (error) {
      console.error("Error serving file:", error);
      res.status(500).json({ message: "Failed to serve file" });
    }
  });
  app2.get("/public-objects/:filePath(*)", async (req, res) => {
    try {
      const filePath = req.params.filePath;
      if (!filePath || filePath.includes("..") || filePath.includes("\0") || path.isAbsolute(filePath)) {
        return res.status(400).json({ message: "Invalid file path" });
      }
      if (filePath.startsWith("uploads/")) {
        const localFilePath = path.join("/tmp", filePath);
        if (existsSync(localFilePath)) {
          const ext = path.extname(filePath).toLowerCase();
          const mimeTypes = {
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".png": "image/png",
            ".gif": "image/gif",
            ".webp": "image/webp",
            ".mp4": "video/mp4",
            ".webm": "video/webm",
            ".mov": "video/quicktime"
          };
          const contentType = mimeTypes[ext] || "application/octet-stream";
          res.setHeader("Content-Type", contentType);
          res.setHeader("Cache-Control", "public, max-age=3600");
          const fileStream = createReadStream(localFilePath);
          fileStream.pipe(res);
          return;
        }
      }
      res.status(404).json({ message: "File not found" });
    } catch (error) {
      console.error("Error serving public file:", error);
      if (!res.headersSent) {
        res.status(500).json({ message: "Failed to serve file" });
      }
    }
  });
  app2.get("/api/projects", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const projects2 = await storage.getUserProjects(userId);
      const currentHost = `${req.protocol}://${req.get("host")}`;
      const rehydratedProjects = projects2.map((project) => {
        const rehydrateUrl = (url) => {
          if (!url) return url;
          if (url.includes("/public-objects/")) {
            const pathMatch = url.match(/\/public-objects\/(.*)/);
            if (pathMatch) {
              return `${currentHost}/public-objects/${pathMatch[1]}`;
            }
          }
          return url;
        };
        return {
          ...project,
          productImageUrl: rehydrateUrl(project.productImageUrl),
          sceneImageUrl: rehydrateUrl(project.sceneImageUrl),
          outputImageUrl: rehydrateUrl(project.outputImageUrl),
          outputVideoUrl: rehydrateUrl(project.outputVideoUrl)
        };
      });
      res.json(rehydratedProjects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });
  app2.post("/api/projects", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const projectData = insertProjectSchema.parse(req.body);
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const creditsNeeded = projectData.contentType === "image" ? 2 : 10;
      const isAdmin = user.email === "admin@test.com";
      if (!isAdmin && user.credits < creditsNeeded) {
        return res.status(400).json({ message: "Insufficient credits" });
      }
      const project = await storage.createProject({
        ...projectData,
        userId,
        creditsUsed: creditsNeeded,
        status: "pending"
      });
      if (!isAdmin) {
        await storage.updateUserCredits(userId, user.credits - creditsNeeded);
      }
      const job = await storage.createJob({
        type: "cgi_generation",
        projectId: project.id,
        userId,
        data: {
          contentType: projectData.contentType,
          videoDurationSeconds: projectData.videoDurationSeconds,
          productImageUrl: projectData.productImageUrl,
          sceneImageUrl: projectData.sceneImageUrl,
          sceneVideoUrl: projectData.sceneVideoUrl,
          description: projectData.description
        },
        priority: projectData.contentType === "video" ? 2 : 1
        // Videos have higher priority
      });
      console.log(`\u{1F3AF} Job created for project ${project.id}: ${job.id}`);
      res.json({
        ...project,
        jobId: job.id
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid project data", errors: error.errors });
      }
      console.error("Error creating project:", error);
      res.status(500).json({ message: "Failed to create project" });
    }
  });
  app2.get("/api/projects/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const project = await storage.getProject(req.params.id);
      if (!project || project.userId !== userId) {
        return res.status(404).json({ message: "Project not found" });
      }
      const job = await storage.getJobByProjectId(project.id);
      res.json({
        ...project,
        job: job ? {
          id: job.id,
          status: job.status,
          progress: job.progress,
          statusMessage: job.statusMessage,
          errorMessage: job.errorMessage
        } : null
      });
    } catch (error) {
      console.error("Error fetching project:", error);
      res.status(500).json({ message: "Failed to fetch project" });
    }
  });
  app2.post("/api/purchase-credits", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const { amount, credits, packageId } = req.body;
      if (!amount || !credits || !packageId) {
        return res.status(400).json({ message: "Missing amount, credits, or packageId" });
      }
      const validPackage = CREDIT_PACKAGES[packageId];
      if (!validPackage || validPackage.price !== amount || validPackage.credits !== credits) {
        return res.status(400).json({ message: "Invalid package selected" });
      }
      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100),
        // Convert to cents
        currency: "usd",
        metadata: {
          userId,
          credits: credits.toString(),
          packageId
        },
        automatic_payment_methods: {
          enabled: true
        }
      });
      const transaction = await storage.createTransaction({
        userId,
        amount: Math.round(amount * 100),
        // Convert to cents
        credits,
        stripePaymentIntentId: paymentIntent.id,
        status: "pending"
      });
      res.json({
        clientSecret: paymentIntent.client_secret,
        transactionId: transaction.id,
        paymentIntentId: paymentIntent.id
      });
    } catch (error) {
      console.error("Error creating payment:", error);
      res.status(500).json({ message: "Failed to create payment" });
    }
  });
  app2.post("/api/jobs/process", isAuthenticated, async (req, res) => {
    try {
      const job = await storage.getNextPendingJob();
      if (!job) {
        return res.json({ message: "No pending jobs" });
      }
      const claimed = await storage.claimJob(job.id);
      if (!claimed) {
        return res.json({ message: "Job was already claimed by another worker" });
      }
      await storage.updateJob(job.id, {
        attempts: job.attempts + 1
      });
      console.log(`\u{1F680} Processing job ${job.id} for project ${job.projectId}`);
      processJobAsync(job.id).catch(async (error) => {
        console.error(`\u274C Job ${job.id} failed:`, error);
        await storage.markJobFailed(job.id, error.message);
      });
      res.json({
        message: "Job processing started",
        jobId: job.id,
        projectId: job.projectId
      });
    } catch (error) {
      console.error("Error processing job:", error);
      res.status(500).json({ error: "Failed to process job" });
    }
  });
  app2.get("/api/jobs/:id/status", isAuthenticated, async (req, res) => {
    try {
      const job = await storage.getJob(req.params.id);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      if (job.userId !== req.user.id) {
        return res.status(403).json({ error: "Access denied" });
      }
      res.json({
        id: job.id,
        status: job.status,
        progress: job.progress,
        statusMessage: job.statusMessage,
        errorMessage: job.errorMessage,
        result: job.result,
        createdAt: job.createdAt,
        completedAt: job.completedAt
      });
    } catch (error) {
      console.error("Error fetching job status:", error);
      res.status(500).json({ error: "Failed to fetch job status" });
    }
  });
  app2.get("/api/projects/:id/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const project = await storage.getProject(req.params.id);
      if (!project || project.userId !== userId) {
        return res.status(404).json({ error: "Project not found" });
      }
      const job = await storage.getJobByProjectId(project.id);
      res.json({
        project: {
          id: project.id,
          status: project.status,
          progress: project.progress,
          outputImageUrl: project.outputImageUrl,
          outputVideoUrl: project.outputVideoUrl,
          errorMessage: project.errorMessage
        },
        job: job ? {
          id: job.id,
          status: job.status,
          progress: job.progress,
          statusMessage: job.statusMessage,
          errorMessage: job.errorMessage
        } : null
      });
    } catch (error) {
      console.error("Error fetching project status:", error);
      res.status(500).json({ error: "Failed to fetch project status" });
    }
  });
  app2.post("/api/webhooks/stripe", async (req, res) => {
    const sig = req.headers["stripe-signature"];
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
    if (!sig) {
      return res.status(400).send("No stripe signature provided");
    }
    try {
      let event;
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      if (!webhookSecret) {
        console.error("STRIPE_WEBHOOK_SECRET environment variable is not set");
        return res.status(500).send("Webhook secret not configured");
      }
      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
      if (event.type === "payment_intent.succeeded") {
        const paymentIntent = event.data.object;
        const { userId, credits, packageId } = paymentIntent.metadata;
        if (!userId || !credits || !packageId) {
          console.error("Missing required metadata in payment intent:", paymentIntent.id);
          return res.status(400).send("Invalid payment metadata");
        }
        console.log(`\u{1F4B3} Payment succeeded: User ${userId} purchased ${credits} credits (PI: ${paymentIntent.id})`);
        let existingTransaction = await storage.getTransactionByPaymentIntent(paymentIntent.id);
        if (existingTransaction && existingTransaction.status === "completed") {
          console.log(`\u26A0\uFE0F Payment intent ${paymentIntent.id} already processed, skipping credit fulfillment`);
          return res.json({ received: true, status: "already_processed" });
        }
        const expectedPackage = CREDIT_PACKAGES[packageId];
        if (!expectedPackage) {
          console.error(`Invalid package ID: ${packageId} for payment intent: ${paymentIntent.id}`);
          return res.status(400).send("Invalid package");
        }
        const expectedAmountCents = Math.round(expectedPackage.price * 100);
        if (paymentIntent.amount !== expectedAmountCents || parseInt(credits) !== expectedPackage.credits) {
          console.error(`Amount/credits mismatch for PI ${paymentIntent.id}: expected ${expectedAmountCents}/${expectedPackage.credits}, got ${paymentIntent.amount}/${credits}`);
          return res.status(400).send("Amount validation failed");
        }
        const user = await storage.getUser(userId);
        if (user && user.email !== "admin@test.com") {
          await storage.updateUserCredits(userId, user.credits + parseInt(credits));
          console.log(`\u2705 Credits updated: User ${userId} now has ${user.credits + parseInt(credits)} credits`);
        }
        if (existingTransaction) {
          await storage.updateTransaction(existingTransaction.id, {
            status: "completed",
            processedAt: /* @__PURE__ */ new Date()
          });
        } else {
          console.log(`\u26A0\uFE0F Creating transaction record for payment intent ${paymentIntent.id}`);
          await storage.createTransaction({
            userId,
            amount: paymentIntent.amount,
            credits: parseInt(credits),
            stripePaymentIntentId: paymentIntent.id,
            status: "completed",
            processedAt: /* @__PURE__ */ new Date()
          });
        }
        console.log(`\u{1F3AF} Idempotent credit fulfillment completed for PI: ${paymentIntent.id}`);
      }
      res.json({ received: true });
    } catch (error) {
      console.error("Webhook error:", error);
      res.status(400).send(`Webhook Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  });
  app2.get("/api/projects/:id/download", isAuthenticated, async (req, res) => {
    try {
      const projectId = req.params.id;
      const userId = req.user.id;
      const project = await storage.getProject(projectId);
      if (!project || project.userId !== userId) {
        return res.status(404).json({ message: "Project not found" });
      }
      if (project.status !== "completed") {
        return res.status(400).json({ message: "Project not completed" });
      }
      const outputUrl = project.contentType === "video" ? project.outputVideoUrl : project.outputImageUrl;
      if (!outputUrl) {
        return res.status(404).json({ message: "Output file not found" });
      }
      if (outputUrl.startsWith("/api/files/")) {
        const filePath = outputUrl.replace("/api/files/", "");
        const fullPath = path.join(process.env.PRIVATE_OBJECT_DIR || "/tmp", filePath);
        try {
          const fileBuffer = await fs.readFile(fullPath);
          let mimeType;
          let fileExt;
          if (project.contentType === "video") {
            mimeType = "video/mp4";
            fileExt = "mp4";
          } else {
            const urlPath = outputUrl.includes("/public-objects/") ? outputUrl.split("/public-objects/")[1] : outputUrl;
            const detectedExt = path.extname(urlPath).toLowerCase();
            const extToMime = {
              ".jpg": "image/jpeg",
              ".jpeg": "image/jpeg",
              ".png": "image/png",
              ".gif": "image/gif",
              ".webp": "image/webp"
            };
            mimeType = extToMime[detectedExt] || "image/png";
            fileExt = detectedExt.replace(".", "") || "png";
          }
          const fileName = `${project.title}_${project.id}.${fileExt}`;
          res.setHeader("Content-Type", mimeType);
          res.setHeader("Content-Disposition", `attachment; filename="${fileName}"`);
          res.send(fileBuffer);
        } catch (error) {
          return res.status(404).json({ message: "File not found" });
        }
      } else {
        res.redirect(outputUrl);
      }
    } catch (error) {
      console.error("Error downloading project:", error);
      res.status(500).json({ message: "Failed to download project" });
    }
  });
  app2.post("/api/admin/make-admin", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      await storage.updateUser(userId, { isAdmin: true });
      res.json({ message: "Admin privileges granted", isAdmin: true });
    } catch (error) {
      console.error("Error granting admin:", error);
      res.status(500).json({ message: "Failed to grant admin privileges" });
    }
  });
  app2.get("/api/admin/users", isAuthenticated, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const users2 = await storage.getAllUsers();
      res.json(users2);
    } catch (error) {
      console.error("Error getting users:", error);
      res.status(500).json({ message: "Failed to get users" });
    }
  });
  app2.get("/api/admin/projects", isAuthenticated, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const projects2 = await storage.getAllProjects();
      res.json(projects2);
    } catch (error) {
      console.error("Error getting projects:", error);
      res.status(500).json({ message: "Failed to get projects" });
    }
  });
  app2.get("/api/actual-costs", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const projects2 = await storage.getUserProjects(userId);
      let totalCostMillicents = 0;
      let imageProjects = 0;
      let videoProjects = 0;
      const projectCosts = projects2.map((project) => {
        const cost = project.actualCost || 0;
        totalCostMillicents += cost;
        if (project.contentType === "image") imageProjects++;
        if (project.contentType === "video") videoProjects++;
        return {
          id: project.id,
          title: project.title,
          contentType: project.contentType,
          status: project.status,
          actualCostMillicents: cost,
          actualCostCents: (cost / 10).toFixed(1),
          // Convert millicents to cents for backward compatibility
          actualCostUSD: (cost / 1e3).toFixed(4),
          // Convert millicents to USD
          createdAt: project.createdAt
        };
      });
      res.json({
        totalCostMillicents,
        totalCostCents: (totalCostMillicents / 10).toFixed(1),
        // Convert to cents for backward compatibility
        totalCostUSD: (totalCostMillicents / 1e3).toFixed(4),
        // Convert to USD
        breakdown: {
          totalProjects: projects2.length,
          imageProjects,
          videoProjects,
          estimatedImageCostMillicents: imageProjects * 4,
          // 4 millicents per image project
          estimatedVideoCostMillicents: videoProjects * 504,
          // 504 millicents per video project (includes image cost)
          estimatedImageCostCents: (imageProjects * 4 / 10).toFixed(1),
          // backward compatibility
          estimatedVideoCostCents: (videoProjects * 504 / 10).toFixed(1)
          // backward compatibility
        },
        projects: projectCosts
      });
    } catch (error) {
      console.error("Error getting actual costs:", error);
      res.status(500).json({ message: "Failed to get actual costs" });
    }
  });
  app2.get("/api/admin/stats", isAuthenticated, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const stats = await storage.getPlatformStats();
      res.json(stats);
    } catch (error) {
      console.error("Error getting stats:", error);
      res.status(500).json({ message: "Failed to get platform stats" });
    }
  });
  app2.post("/api/projects/recover", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      console.log("\u{1F504} RECOVERY: Starting recovery process for user:", userId);
      const userProjects = await storage.getUserProjects(userId);
      const recoverableProjects = userProjects.filter(
        (project) => (project.status === "failed" || project.status === "processing") && (project.klingVideoTaskId || project.klingSoundTaskId)
      );
      console.log("\u{1F50D} RECOVERY: Found projects for potential recovery:", {
        total: userProjects.length,
        recoverable: recoverableProjects.length,
        recoverableIds: recoverableProjects.map((p) => p.id)
      });
      if (recoverableProjects.length === 0) {
        return res.json({
          message: "No projects found for recovery",
          recovered: 0,
          total: 0
        });
      }
      const klingApiKey = process.env.KLING_API_KEY;
      if (!klingApiKey) {
        throw new Error("KLING_API_KEY environment variable is required");
      }
      let recoveredCount = 0;
      const recoveryResults = [];
      for (const project of recoverableProjects) {
        console.log("\u{1F50E} RECOVERY: Checking project:", {
          projectId: project.id,
          title: project.title,
          status: project.status,
          hasVideoTaskId: !!project.klingVideoTaskId,
          hasSoundTaskId: !!project.klingSoundTaskId
        });
        try {
          let recovered = false;
          let videoUrl = project.outputVideoUrl;
          if (project.klingVideoTaskId && !project.outputVideoUrl) {
            console.log("\u{1F3AC} RECOVERY: Checking video task:", project.klingVideoTaskId);
            const videoStatusResponse = await fetch(`https://api.piapi.ai/api/v1/task/${project.klingVideoTaskId}`, {
              headers: { "X-API-Key": klingApiKey }
            });
            if (videoStatusResponse.ok) {
              const videoResult = await videoStatusResponse.json();
              const videoData = videoResult.data || videoResult;
              console.log("\u{1F4FA} RECOVERY: Video task status:", {
                taskId: project.klingVideoTaskId,
                status: videoData.status,
                hasOutput: !!videoData.output
              });
              if (videoData.status === "completed" && videoData.output) {
                videoUrl = videoData.output;
                recovered = true;
                console.log("\u2705 RECOVERY: Found completed video:", videoUrl);
              }
            }
          }
          if (project.klingSoundTaskId && videoUrl && project.includeAudio) {
            console.log("\u{1F50A} RECOVERY: Checking audio task:", project.klingSoundTaskId);
            const audioStatusResponse = await fetch(`https://api.piapi.ai/api/v1/task/${project.klingSoundTaskId}`, {
              headers: { "X-API-Key": klingApiKey }
            });
            if (audioStatusResponse.ok) {
              const audioResult = await audioStatusResponse.json();
              const audioData = audioResult.data || audioResult;
              console.log("\u{1F3B5} RECOVERY: Audio task status:", {
                taskId: project.klingSoundTaskId,
                status: audioData.status,
                hasOutput: !!audioData.output
              });
              if (audioData.status === "completed" && audioData.output) {
                videoUrl = audioData.output;
                recovered = true;
                console.log("\u2705 RECOVERY: Found completed video with audio:", videoUrl);
              }
            }
          }
          if (recovered && videoUrl) {
            await storage.updateProject(project.id, {
              status: "completed",
              outputVideoUrl: videoUrl,
              progress: 100,
              errorMessage: null
              // Clear error message
            });
            recoveredCount++;
            recoveryResults.push({
              projectId: project.id,
              title: project.title,
              status: "recovered",
              videoUrl
            });
            console.log("\u{1F389} RECOVERY SUCCESS:", {
              projectId: project.id,
              title: project.title,
              videoUrl: videoUrl.substring(0, 50) + "..."
            });
          } else {
            recoveryResults.push({
              projectId: project.id,
              title: project.title,
              status: "still_processing_or_failed",
              reason: !videoUrl ? "No completed video found" : "Unknown issue"
            });
          }
        } catch (recoveryError) {
          console.error("\u274C RECOVERY ERROR for project:", {
            projectId: project.id,
            error: recoveryError instanceof Error ? recoveryError.message : "Unknown error"
          });
          recoveryResults.push({
            projectId: project.id,
            title: project.title,
            status: "recovery_failed",
            error: recoveryError instanceof Error ? recoveryError.message : "Unknown error"
          });
        }
      }
      console.log("\u{1F3C1} RECOVERY COMPLETE:", {
        totalChecked: recoverableProjects.length,
        recovered: recoveredCount,
        results: recoveryResults
      });
      res.json({
        message: `Recovery complete: ${recoveredCount} of ${recoverableProjects.length} projects recovered`,
        recovered: recoveredCount,
        total: recoverableProjects.length,
        results: recoveryResults
      });
    } catch (error) {
      console.error("\u274C RECOVERY ENDPOINT ERROR:", error);
      res.status(500).json({
        error: "Recovery failed",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}
async function processJobAsync(jobId) {
  try {
    const job = await storage.getJob(jobId);
    if (!job) {
      throw new Error(`Job ${jobId} not found`);
    }
    const projectId = job.projectId;
    console.log(`\u{1F3AF} Processing job ${jobId} for project ${projectId}`);
    await processProjectFromJob(job);
    console.log(`\u2705 Job ${jobId} completed successfully`);
  } catch (error) {
    console.error(`\u274C Job ${jobId} failed:`, error);
    throw error;
  }
}
async function processProjectFromJob(job) {
  const projectId = job.projectId;
  const jobData = job.data;
  let totalCostMillicents = 0;
  try {
    console.log(`\u{1F680} Starting CGI processing for project ${projectId}`);
    const project = await storage.getProject(projectId);
    console.log(`\u{1F50D} Project details:`, {
      id: projectId,
      contentType: project?.contentType,
      status: project?.status,
      title: project?.title
    });
    if (!project) {
      throw new Error("Project not found");
    }
    await storage.updateProject(projectId, {
      status: "processing",
      progress: 10
    });
    await storage.updateJob(job.id, {
      progress: 10,
      statusMessage: "Starting CGI processing..."
    });
    await storage.updateProject(projectId, {
      status: "enhancing_prompt",
      progress: 25
    });
    await storage.updateJob(job.id, {
      progress: 25,
      statusMessage: "Enhancing prompt with AI..."
    });
    const extractRelativePath = (url) => {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        const match = pathname.match(/\/public-objects\/(.+)/);
        return match ? match[1] : url;
      } catch (error) {
        console.warn("Could not parse URL, using as path:", url);
        return url;
      }
    };
    const productImagePath = jobData.productImageUrl || project.productImageUrl || "";
    const sceneImagePath = jobData.sceneImageUrl || project.sceneImageUrl || "";
    const sceneVideoPath = jobData.sceneVideoUrl || project.sceneVideoUrl || "";
    console.log("Media paths for Gemini:", {
      productImagePath,
      sceneImagePath,
      sceneVideoPath,
      contentType: project.contentType
    });
    const scenePath = project.contentType === "video" && sceneVideoPath ? sceneVideoPath : sceneImagePath;
    const isSceneVideo = project.contentType === "video" && sceneVideoPath;
    let enhancedPrompt;
    let videoPromptData = {};
    try {
      if (project.contentType === "video") {
        const { enhanceVideoPromptWithGemini: enhanceVideoPromptWithGemini2 } = await Promise.resolve().then(() => (init_gemini(), gemini_exports));
        const result = await enhanceVideoPromptWithGemini2(
          productImagePath,
          scenePath,
          project.description || "CGI video generation",
          {
            duration: project.videoDurationSeconds || void 0,
            isSceneVideo: !!isSceneVideo
          }
        );
        enhancedPrompt = result.enhancedPrompt;
        videoPromptData = {
          imageScenePrompt: result.imageScenePrompt,
          videoMotionPrompt: result.videoMotionPrompt,
          qualityNegativePrompt: result.qualityNegativePrompt
        };
        console.log("Video prompt separation:", {
          hasImageScene: !!videoPromptData.imageScenePrompt,
          hasVideoMotion: !!videoPromptData.videoMotionPrompt,
          hasNegativePrompt: !!videoPromptData.qualityNegativePrompt,
          imageSceneLength: videoPromptData.imageScenePrompt?.length || 0,
          videoMotionLength: videoPromptData.videoMotionPrompt?.length || 0
        });
      } else {
        enhancedPrompt = await enhancePromptWithGemini(
          productImagePath,
          scenePath,
          project.description || "CGI image generation"
        );
      }
    } finally {
      totalCostMillicents += COSTS.GEMINI_PROMPT_ENHANCEMENT;
    }
    await storage.updateProject(projectId, {
      enhancedPrompt,
      progress: 50
    });
    await storage.updateProject(projectId, {
      status: "generating_image",
      progress: 60
    });
    let geminiImageResult;
    const imagePrompt = videoPromptData.imageScenePrompt || enhancedPrompt;
    console.log("Using prompt for image generation:", {
      usingImageScene: !!videoPromptData.imageScenePrompt,
      promptLength: imagePrompt.length,
      promptType: videoPromptData.imageScenePrompt ? "static-scene-focused" : "combined"
    });
    try {
      geminiImageResult = await generateImageWithGemini(
        productImagePath,
        sceneImagePath,
        imagePrompt
        // Use separated static scene prompt when available
      );
    } finally {
      totalCostMillicents += COSTS.GEMINI_IMAGE_GENERATION;
    }
    console.log("Gemini image generation result:", {
      base64Length: geminiImageResult.base64.length,
      mimeType: geminiImageResult.mimeType,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    const mimeToExtension = {
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp"
    };
    const fileExtension = mimeToExtension[geminiImageResult.mimeType] || "png";
    console.log("Using file extension:", fileExtension, "for MIME type:", geminiImageResult.mimeType);
    const imageBuffer = Buffer.from(geminiImageResult.base64, "base64");
    if (imageBuffer.length < 1e3) {
      console.warn("Generated image is suspiciously small - scene preservation may be insufficient");
    }
    console.log("Scene preservation check - generated image size:", imageBuffer.length, "bytes");
    const { v2: cloudinary } = await import("cloudinary");
    cloudinary.config({
      cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET
    });
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const publicId = `cgi-generated/generated-${uniqueSuffix}`;
    console.log("Uploading to Cloudinary with public_id:", publicId);
    const cloudinaryResult = await new Promise((resolve, reject) => {
      cloudinary.uploader.upload_stream(
        {
          resource_type: "image",
          public_id: publicId,
          folder: "cgi-generated",
          format: fileExtension,
          quality: "auto:best"
        },
        (error, result) => {
          if (error) {
            console.error("Cloudinary upload error:", error);
            reject(error);
          } else {
            console.log("Cloudinary upload success:", {
              public_id: result.public_id,
              url: result.secure_url,
              format: result.format,
              bytes: result.bytes
            });
            resolve(result);
          }
        }
      ).end(imageBuffer);
    });
    const imageResult = { url: cloudinaryResult.secure_url };
    await storage.updateProject(projectId, {
      outputImageUrl: imageResult.url,
      progress: 75
    });
    let finalVideoPrompt = videoPromptData.videoMotionPrompt || enhancedPrompt;
    let audioPrompt = void 0;
    console.log("Base video prompt selection:", {
      usingMotionPrompt: !!videoPromptData.videoMotionPrompt,
      motionPromptLength: videoPromptData.videoMotionPrompt?.length || 0,
      fallbackPromptLength: enhancedPrompt.length,
      promptType: videoPromptData.videoMotionPrompt ? "motion-focused" : "combined"
    });
    if (project.contentType === "video") {
      console.log("\u{1F3AC} Step 2.5: Analyzing generated image for optimal video production...");
      await storage.updateProject(projectId, {
        status: "generating_video",
        progress: 78
      });
      try {
        const { enhanceVideoPromptFromGeneratedImage: enhanceVideoPromptFromGeneratedImage2 } = await Promise.resolve().then(() => (init_gemini(), gemini_exports));
        const videoEnhancement = await enhanceVideoPromptFromGeneratedImage2(
          geminiImageResult,
          // Use the generated image data
          {
            duration: project.videoDurationSeconds || 10,
            includeAudio: false,
            userDescription: project.description || "",
            productName: project.title || "Product"
          }
        );
        const basePrompt = finalVideoPrompt;
        finalVideoPrompt = `${basePrompt}

Camera and Production: ${videoEnhancement.enhancedVideoPrompt}`;
        console.log("\u{1F3AC} Video prompt merged with enhancement:", {
          basePromptLength: basePrompt.length,
          enhancementLength: videoEnhancement.enhancedVideoPrompt.length,
          finalPromptLength: finalVideoPrompt.length,
          baseType: videoPromptData.videoMotionPrompt ? "motion-focused" : "combined"
        });
        audioPrompt = videoEnhancement.audioPrompt;
        totalCostMillicents += COSTS.GEMINI_VIDEO_ANALYSIS;
        console.log("\u{1F3AC} Video prompt enhanced successfully:", {
          originalPromptLength: enhancedPrompt.length,
          enhancedPromptLength: finalVideoPrompt.length,
          cameraMovements: videoEnhancement.cameraMovements.substring(0, 80) + "...",
          audioIncluded: !!audioPrompt,
          additionalCost: "$0.003"
        });
      } catch (error) {
        console.warn("\u26A0\uFE0F Video prompt enhancement failed, using original:", error);
        await storage.updateProject(projectId, {
          status: "generating_video",
          progress: 80
        });
      }
    }
    console.log("\u{1F3AC} Checking video generation condition:", {
      projectId,
      contentType: project.contentType,
      shouldGenerateVideo: project.contentType === "video",
      imageUrl: imageResult.url,
      promptLength: finalVideoPrompt.length
    });
    if (project.contentType === "video") {
      console.log("\u{1F3AC} Starting video generation for project:", projectId);
      await storage.updateProject(projectId, {
        status: "generating_video",
        progress: 80
      });
      try {
        console.log("\u{1F3AC} Attempting to import kling-video service...");
        const { generateVideoWithKling: generateVideoWithKling2 } = await Promise.resolve().then(() => (init_kling_video(), kling_video_exports));
        console.log("\u{1F3AC} kling-video service imported successfully:", typeof generateVideoWithKling2);
        let videoResult;
        try {
          console.log("\u{1F3AC} Calling generateVideoWithKling with:", {
            imageUrl: imageResult.url,
            promptLength: finalVideoPrompt.length,
            promptType: finalVideoPrompt === enhancedPrompt ? "original" : "video-enhanced",
            duration: project.videoDurationSeconds || 10,
            includeAudio: false,
            hasAudioPrompt: false
          });
          const effectiveNegativePrompt = videoPromptData.qualityNegativePrompt || "deformed, distorted, unnatural proportions, melting, morphing, blurry, low quality";
          console.log("\u{1F3AC} Kling API negative prompt validation:", {
            hasCustomNegative: !!videoPromptData.qualityNegativePrompt,
            negativePromptLength: effectiveNegativePrompt.length,
            negativePromptPreview: effectiveNegativePrompt.substring(0, 50) + "..."
          });
          if (!effectiveNegativePrompt || effectiveNegativePrompt.trim().length === 0) {
            throw new Error("Negative prompt must not be empty for video generation");
          }
          videoResult = await generateVideoWithKling2(
            imageResult.url,
            finalVideoPrompt,
            // Use enhanced video prompt instead of original
            project.videoDurationSeconds || 10,
            false,
            // Audio disabled
            effectiveNegativePrompt,
            // For recovery system
            projectId,
            storage
          );
          console.log("\u{1F3AC} generateVideoWithKling returned:", {
            success: !!videoResult,
            hasUrl: !!videoResult?.url,
            videoUrl: videoResult?.url?.substring(0, 50) + "...",
            hasFullTaskDetails: !!videoResult?.fullTaskDetails,
            taskDetailsSize: videoResult?.fullTaskDetails ? JSON.stringify(videoResult.fullTaskDetails).length : 0
          });
          await storage.updateProject(projectId, {
            outputVideoUrl: videoResult.url,
            fullTaskDetails: videoResult.fullTaskDetails || null,
            // NEW: Save complete task details for UI display
            progress: 95
          });
          console.log("Video generation completed successfully:", {
            projectId,
            videoUrl: videoResult.url,
            duration: videoResult.duration
          });
        } finally {
          totalCostMillicents += COSTS.VIDEO_GENERATION;
        }
      } catch (videoError) {
        console.error("\u274C VIDEO GENERATION FAILED:", {
          projectId,
          errorMessage: videoError instanceof Error ? videoError.message : "Unknown error",
          errorStack: videoError instanceof Error ? videoError.stack : "No stack trace",
          imageUrl: imageResult.url,
          promptLength: finalVideoPrompt.length
        });
        await storage.updateProject(projectId, {
          errorMessage: `Video generation failed: ${videoError instanceof Error ? videoError.message : "Unknown error"}`,
          status: "failed"
        });
        throw videoError;
      }
    }
    console.log(`Total actual cost for project ${projectId}: $${(totalCostMillicents / 1e3).toFixed(4)} (${totalCostMillicents} millicents)`);
    const finalImageUrl = imageResult?.url || null;
    const finalVideoUrl = project.contentType === "video" ? project.outputVideoUrl : null;
    await storage.updateProject(projectId, {
      status: "completed",
      progress: 100,
      actualCost: totalCostMillicents
    });
    await storage.markJobCompleted(job.id, {
      outputImageUrl: finalImageUrl,
      outputVideoUrl: finalVideoUrl,
      totalCost: totalCostMillicents,
      costInUSD: (totalCostMillicents / 1e3).toFixed(4)
    });
    console.log(`CGI processing completed for project ${projectId}`);
  } catch (error) {
    console.error(`CGI processing failed for project ${projectId}:`, error);
    console.log(`Actual cost incurred despite failure: $${(totalCostMillicents / 1e3).toFixed(4)} (${totalCostMillicents} millicents)`);
    await storage.updateProject(projectId, {
      status: "failed",
      errorMessage: error instanceof Error ? error.message : "Unknown error",
      actualCost: totalCostMillicents
    });
    await storage.markJobFailed(job.id, error instanceof Error ? error.message : "Unknown error");
  }
}

// server/vite.ts
import express from "express";
import fs2 from "fs";
import path3 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path2 from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      ),
      await import("@replit/vite-plugin-dev-banner").then(
        (m) => m.devBanner()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path2.resolve(import.meta.dirname, "client", "src"),
      "@shared": path2.resolve(import.meta.dirname, "shared"),
      "@assets": path2.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path2.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path2.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path3.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs2.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path3.resolve(import.meta.dirname, "public");
  if (!fs2.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path3.resolve(distPath, "index.html"));
  });
}

// server/index.ts
import serverless from "serverless-http";
var app = express2();
app.use("/api/webhooks/stripe", express2.raw({ type: "application/json" }));
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
var isAppInitialized = false;
var initPromise;
app.use((req, res, next) => {
  const start = Date.now();
  const path4 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path4.startsWith("/api")) {
      let logLine = `${req.method} ${path4} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
async function initializeApp() {
  if (isAppInitialized) return;
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  if (!process.env.VERCEL && process.env.NODE_ENV !== "production") {
    const port = parseInt(process.env.PORT || "5000", 10);
    server.listen({
      port,
      host: "0.0.0.0",
      reusePort: true
    }, () => {
      log(`serving on port ${port}`);
    });
  }
  isAppInitialized = true;
}
initPromise = initializeApp();
var serverlessApp;
var getServerlessApp = async () => {
  if (!serverlessApp) {
    await initPromise;
    serverlessApp = serverless(app);
  }
  return serverlessApp;
};
var handler = async (req, res) => {
  const sls = await getServerlessApp();
  return sls(req, res);
};
var index_default = handler;
export {
  index_default as default
};